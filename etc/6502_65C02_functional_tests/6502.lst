AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6011 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2015  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 21-oct-2015
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = $0
                        
                        ;data_segment memory start address, $6A (106) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0000 =                  disable_decimal = 0
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                        	lda #0
                        	sta $ff00
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000d : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
000e : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0012 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0016 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001a : 1702             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001c : 1802                     dw  abs1+1
001e : 1902                     dw  abs1+2
0020 : 1a02                     dw  abs1+3
0022 : 1b02                     dw  abs7f
0024 : 1f01             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0026 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0028 : 0402                     dw  abst+1
002a : 0502                     dw  abst+2
002c : 0602                     dw  abst+3
002e : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0030 : 4e02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0032 : 4f02                     dw  absAN+1
0034 : 5002                     dw  absAN+2
0036 : 5102                     dw  absAN+3
0038 : 5202             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003a : 5302                     dw  absEO+1
003c : 5402                     dw  absEO+2
003e : 5502                     dw  absEO+3
0040 : 4a02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0042 : 4b02                     dw  absOR+1
0044 : 4c02                     dw  absOR+2
0046 : 4d02                     dw  absOR+3
                        ;add/subtract indirect pointers
0048 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004a : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004c : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
004e : 0501             sbiy2   dw  sba2-$ff
0050 :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;5 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 000000                   ds  3               ;fill remaining bytes
0208 :                  data_bss
                            if load_data_direct = 1
0208 : 2900             ex_andi and #0              ;execute immediate opcodes
020a : 60                       rts
020b : 4900             ex_eori eor #0              ;execute immediate opcodes
020d : 60                       rts
020e : 0900             ex_orai ora #0              ;execute immediate opcodes
0210 : 60                       rts
0211 : 6900             ex_adci adc #0              ;execute immediate opcodes
0213 : 60                       rts
0214 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0216 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
0217 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021b : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021c : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0220 :                  rASL                        ;expected result ASL & ROL -carry  
0220 : 86048200         rROL    db  $86,$04,$82,0   ; "
0224 : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0228 :                  rLSR                        ;expected result LSR & ROR -carry
0228 : 61412000         rROR    db  $61,$41,$20,0   ; "
022c : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0230 :                  fASL                        ;expected flags for shifts
0230 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
0234 : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0238 :                  fLSR
0238 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
023c : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0240 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0245 : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
024a : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
024e : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0252 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0256 : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
025a : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
025e : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0262 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0266 : 02800080         absflo  db  fz,fn,0,fn
026a :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0438 : ad0002          >            lda test_case   ;previous test
043b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
043d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
043f : a901            >            lda #test_num   ;*** next tests' number
0441 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0444 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0446 :                  range_loop
0446 : 88                       dey             ;next relative address
0447 : 98                       tya
0448 : aa                       tax             ;precharge count to end of loop
0449 : 1008                     bpl range_fw    ;calculate relative address
044b : 18                       clc             ;avoid branch self or to relative address of branch
044c : 6902                     adc #2
044e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
044f : ea                       nop
0450 : ea                       nop
0451 : ea                       nop
0452 : ea                       nop
0453 :                  range_fw
0453 : ea                       nop
0454 : ea                       nop
0455 : ea                       nop
0456 : ea                       nop
0457 : ea                       nop
0458 : 497f                     eor #$7f        ;complement except sign
045a : 8de604                   sta range_adr   ;load into test target
045d : a900                     lda #0          ;should set zero flag in status register
045f : 4ce504                   jmp range_op
                                
0462 : ca                       dex             ; offset landing zone - backward branch too far
0463 : ca                       dex
0464 : ca                       dex
0465 : ca                       dex
0466 : ca                       dex
                                ;relative address target field with branch under test in the middle
0467 : ca                       dex             ;-128 - max backward
0468 : ca                       dex
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex
046e : ca                       dex
046f : ca                       dex             ;-120
0470 : ca                       dex
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex
0478 : ca                       dex
0479 : ca                       dex             ;-110
047a : ca                       dex
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex
0482 : ca                       dex
0483 : ca                       dex             ;-100
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex             ;-90
048e : ca                       dex
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex             ;-80
0498 : ca                       dex
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex             ;-70
04a2 : ca                       dex
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex             ;-60
04ac : ca                       dex
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex             ;-50
04b6 : ca                       dex
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex             ;-40
04c0 : ca                       dex
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex             ;-30
04ca : ca                       dex
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex             ;-20
04d4 : ca                       dex
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex             ;-10
04de : ca                       dex
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex             ;-3
04e5 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04e6 =                  range_adr   = *+1       ;modifiable relative address
04e5 : f03e                     beq *+64        ;+64 if called without modification
04e7 : ca                       dex             ;+0
04e8 : ca                       dex
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex             ;+10
04f2 : ca                       dex
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex             ;+20
04fc : ca                       dex
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex             ;+30
0506 : ca                       dex
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex             ;+40
0510 : ca                       dex
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex             ;+50
051a : ca                       dex
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex             ;+60
0524 : ca                       dex
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex             ;+70
052e : ca                       dex
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex             ;+80
0538 : ca                       dex
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex             ;+90
0542 : ca                       dex
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex             ;+100
054c : ca                       dex
054d : ca                       dex
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex             ;+110
0556 : ca                       dex
0557 : ca                       dex
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex             ;+120
0560 : ca                       dex
0561 : ca                       dex
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ea                       nop             ;offset landing zone - forward branch too far
0567 : ea                       nop
0568 : ea                       nop
0569 : ea                       nop
056a : ea                       nop
056b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
056d : 4c6d05          >        jmp *           ;failed anyway
                        
0570 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0571 : ea                       nop
0572 : ea                       nop
0573 : ea                       nop
0574 : ea                       nop
0575 :                  range_ok
0575 : ea                       nop
0576 : ea                       nop
0577 : ea                       nop
0578 : ea                       nop
0579 : ea                       nop
057a : c000                     cpy #0
057c : f003                     beq range_end   
057e : 4c4604                   jmp range_loop
0581 :                  range_end               ;range test successful
                            endif
                                next_test
0581 : ad0002          >            lda test_case   ;previous test
0584 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0586 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
0588 : a902            >            lda #test_num   ;*** next tests' number
058a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
058d : c001                     cpy #1          ;testing BNE true
058f : d003                     bne test_bne
                                trap 
0591 : 4c9105          >        jmp *           ;failed anyway
                        
0594 :                  test_bne
0594 : a900                     lda #0 
0596 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
0598 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
059a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
059c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
059e : c901                     cmp #1
                                trap_eq 
05a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05a4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05a6 : aa                       tax 
05a7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ab : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05ad : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05af : e001                     cpx #1
                                trap_eq 
05b1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05b3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05b5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05b7 : a8                       tay 
05b8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05bc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05be : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05c0 : c001                     cpy #1
                                trap_eq 
05c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05c4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05c6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05c8 : ad0002          >            lda test_case   ;previous test
05cb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05cf : a903            >            lda #test_num   ;*** next tests' number
05d1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05d4 : a2ff                     ldx #$ff        ;initialize stack
05d6 : 9a                       txs
05d7 : a955                     lda #$55
05d9 : 48                       pha
05da : a9aa                     lda #$aa
05dc : 48                       pha
05dd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
05e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e2 : ba                       tsx
05e3 : 8a                       txa             ;overwrite accu
05e4 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
05e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e8 : 68                       pla
05e9 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
05eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
05ed : 68                       pla
05ee : c955                     cmp #$55
                                trap_ne
05f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f2 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f7 : ba                       tsx
05f8 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05fc : ad0002          >            lda test_case   ;previous test
05ff : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0601 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0603 : a904            >            lda #test_num   ;*** next tests' number
0605 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0608 : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
060a : 48              >            pha         ;use stack to load status
060b : 28              >            plp
                        
060c : 101a                     bpl nbr1        ;branches should not be taken
060e : 501b                     bvc nbr2
0610 : 901c                     bcc nbr3
0612 : d01d                     bne nbr4
0614 : 3003                     bmi br1         ;branches should be taken
                                trap 
0616 : 4c1606          >        jmp *           ;failed anyway
                        
0619 : 7003             br1     bvs br2
                                trap 
061b : 4c1b06          >        jmp *           ;failed anyway
                        
061e : b003             br2     bcs br3
                                trap 
0620 : 4c2006          >        jmp *           ;failed anyway
                        
0623 : f00f             br3     beq br4
                                trap 
0625 : 4c2506          >        jmp *           ;failed anyway
                        
0628 :                  nbr1
                                trap            ;previous bpl taken 
0628 : 4c2806          >        jmp *           ;failed anyway
                        
062b :                  nbr2
                                trap            ;previous bvc taken
062b : 4c2b06          >        jmp *           ;failed anyway
                        
062e :                  nbr3
                                trap            ;previous bcc taken
062e : 4c2e06          >        jmp *           ;failed anyway
                        
0631 :                  nbr4
                                trap            ;previous bne taken
0631 : 4c3106          >        jmp *           ;failed anyway
                        
0634 : 08               br4     php
0635 : ba                       tsx
0636 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0638 : d0fe            >        bne *           ;failed not equal (non zero)
                        
063a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
063b : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
063d : d0fe            >        bne *           ;failed not equal (non zero)
                        
063f : ba                       tsx
0640 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0642 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0644 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0646 : 48              >            pha         ;use stack to load status
0647 : 28              >            plp
                        
0648 : 301a                     bmi nbr11       ;branches should not be taken
064a : 701b                     bvs nbr12
064c : b01c                     bcs nbr13
064e : f01d                     beq nbr14
0650 : 1003                     bpl br11        ;branches should be taken
                                trap 
0652 : 4c5206          >        jmp *           ;failed anyway
                        
0655 : 5003             br11    bvc br12
                                trap 
0657 : 4c5706          >        jmp *           ;failed anyway
                        
065a : 9003             br12    bcc br13
                                trap 
065c : 4c5c06          >        jmp *           ;failed anyway
                        
065f : d00f             br13    bne br14
                                trap 
0661 : 4c6106          >        jmp *           ;failed anyway
                        
0664 :                  nbr11
                                trap            ;previous bmi taken 
0664 : 4c6406          >        jmp *           ;failed anyway
                        
0667 :                  nbr12
                                trap            ;previous bvs taken 
0667 : 4c6706          >        jmp *           ;failed anyway
                        
066a :                  nbr13
                                trap            ;previous bcs taken 
066a : 4c6a06          >        jmp *           ;failed anyway
                        
066d :                  nbr14
                                trap            ;previous beq taken 
066d : 4c6d06          >        jmp *           ;failed anyway
                        
0670 : 08               br14    php
0671 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0672 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0674 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0676 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
0678 : 48              >            pha         ;use stack to load status
0679 : 28              >            plp
                        
067a : d002                     bne brzs1
067c : f003                     beq brzs2
067e :                  brzs1
                                trap            ;branch zero/non zero
067e : 4c7e06          >        jmp *           ;failed anyway
                        
0681 : b002             brzs2   bcs brzs3
0683 : 9003                     bcc brzs4
0685 :                  brzs3
                                trap            ;branch carry/no carry
0685 : 4c8506          >        jmp *           ;failed anyway
                        
0688 : 3002             brzs4   bmi brzs5
068a : 1003                     bpl brzs6
068c :                  brzs5
                                trap            ;branch minus/plus
068c : 4c8c06          >        jmp *           ;failed anyway
                        
068f : 7002             brzs6   bvs brzs7
0691 : 5003                     bvc brzs8
0693 :                  brzs7
                                trap            ;branch overflow/no overflow
0693 : 4c9306          >        jmp *           ;failed anyway
                        
0696 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0696 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
0698 : 48              >            pha         ;use stack to load status
0699 : 28              >            plp
                        
069a : f002                     beq brcs1
069c : d003                     bne brcs2
069e :                  brcs1
                                trap            ;branch zero/non zero
069e : 4c9e06          >        jmp *           ;failed anyway
                        
06a1 : 9002             brcs2   bcc brcs3
06a3 : b003                     bcs brcs4
06a5 :                  brcs3
                                trap            ;branch carry/no carry
06a5 : 4ca506          >        jmp *           ;failed anyway
                        
06a8 : 3002             brcs4   bmi brcs5
06aa : 1003                     bpl brcs6
06ac :                  brcs5
                                trap            ;branch minus/plus
06ac : 4cac06          >        jmp *           ;failed anyway
                        
06af : 7002             brcs6   bvs brcs7
06b1 : 5003                     bvc brcs8
06b3 :                  brcs7
                                trap            ;branch overflow/no overflow
06b3 : 4cb306          >        jmp *           ;failed anyway
                        
                        
06b6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
06b6 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
06b8 : 48              >            pha         ;use stack to load status
06b9 : 28              >            plp
                        
06ba : f002                     beq brmi1
06bc : d003                     bne brmi2
06be :                  brmi1
                                trap            ;branch zero/non zero
06be : 4cbe06          >        jmp *           ;failed anyway
                        
06c1 : b002             brmi2   bcs brmi3
06c3 : 9003                     bcc brmi4
06c5 :                  brmi3
                                trap            ;branch carry/no carry
06c5 : 4cc506          >        jmp *           ;failed anyway
                        
06c8 : 1002             brmi4   bpl brmi5
06ca : 3003                     bmi brmi6
06cc :                  brmi5
                                trap            ;branch minus/plus
06cc : 4ccc06          >        jmp *           ;failed anyway
                        
06cf : 7002             brmi6   bvs brmi7
06d1 : 5003                     bvc brmi8
06d3 :                  brmi7
                                trap            ;branch overflow/no overflow
06d3 : 4cd306          >        jmp *           ;failed anyway
                        
06d6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06d6 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
06d8 : 48              >            pha         ;use stack to load status
06d9 : 28              >            plp
                        
06da : f002                     beq brvs1
06dc : d003                     bne brvs2
06de :                  brvs1
                                trap            ;branch zero/non zero
06de : 4cde06          >        jmp *           ;failed anyway
                        
06e1 : b002             brvs2   bcs brvs3
06e3 : 9003                     bcc brvs4
06e5 :                  brvs3
                                trap            ;branch carry/no carry
06e5 : 4ce506          >        jmp *           ;failed anyway
                        
06e8 : 3002             brvs4   bmi brvs5
06ea : 1003                     bpl brvs6
06ec :                  brvs5
                                trap            ;branch minus/plus
06ec : 4cec06          >        jmp *           ;failed anyway
                        
06ef : 5002             brvs6   bvc brvs7
06f1 : 7003                     bvs brvs8
06f3 :                  brvs7
                                trap            ;branch overflow/no overflow
06f3 : 4cf306          >        jmp *           ;failed anyway
                        
06f6 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06f6 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
06f8 : 48              >            pha         ;use stack to load status
06f9 : 28              >            plp
                        
06fa : f002                     beq brzc1
06fc : d003                     bne brzc2
06fe :                  brzc1
                                trap            ;branch zero/non zero
06fe : 4cfe06          >        jmp *           ;failed anyway
                        
0701 : 9002             brzc2   bcc brzc3
0703 : b003                     bcs brzc4
0705 :                  brzc3
                                trap            ;branch carry/no carry
0705 : 4c0507          >        jmp *           ;failed anyway
                        
0708 : 1002             brzc4   bpl brzc5
070a : 3003                     bmi brzc6
070c :                  brzc5
                                trap            ;branch minus/plus
070c : 4c0c07          >        jmp *           ;failed anyway
                        
070f : 5002             brzc6   bvc brzc7
0711 : 7003                     bvs brzc8
0713 :                  brzc7
                                trap            ;branch overflow/no overflow
0713 : 4c1307          >        jmp *           ;failed anyway
                        
0716 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0716 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
0718 : 48              >            pha         ;use stack to load status
0719 : 28              >            plp
                        
071a : d002                     bne brcc1
071c : f003                     beq brcc2
071e :                  brcc1
                                trap            ;branch zero/non zero
071e : 4c1e07          >        jmp *           ;failed anyway
                        
0721 : b002             brcc2   bcs brcc3
0723 : 9003                     bcc brcc4
0725 :                  brcc3
                                trap            ;branch carry/no carry
0725 : 4c2507          >        jmp *           ;failed anyway
                        
0728 : 1002             brcc4   bpl brcc5
072a : 3003                     bmi brcc6
072c :                  brcc5
                                trap            ;branch minus/plus
072c : 4c2c07          >        jmp *           ;failed anyway
                        
072f : 5002             brcc6   bvc brcc7
0731 : 7003                     bvs brcc8
0733 :                  brcc7
                                trap            ;branch overflow/no overflow
0733 : 4c3307          >        jmp *           ;failed anyway
                        
0736 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0736 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
0738 : 48              >            pha         ;use stack to load status
0739 : 28              >            plp
                        
073a : d002                     bne brpl1
073c : f003                     beq brpl2
073e :                  brpl1
                                trap            ;branch zero/non zero
073e : 4c3e07          >        jmp *           ;failed anyway
                        
0741 : 9002             brpl2   bcc brpl3
0743 : b003                     bcs brpl4
0745 :                  brpl3
                                trap            ;branch carry/no carry
0745 : 4c4507          >        jmp *           ;failed anyway
                        
0748 : 3002             brpl4   bmi brpl5
074a : 1003                     bpl brpl6
074c :                  brpl5
                                trap            ;branch minus/plus
074c : 4c4c07          >        jmp *           ;failed anyway
                        
074f : 5002             brpl6   bvc brpl7
0751 : 7003                     bvs brpl8
0753 :                  brpl7
                                trap            ;branch overflow/no overflow
0753 : 4c5307          >        jmp *           ;failed anyway
                        
0756 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0756 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
0758 : 48              >            pha         ;use stack to load status
0759 : 28              >            plp
                        
075a : d002                     bne brvc1
075c : f003                     beq brvc2
075e :                  brvc1
                                trap            ;branch zero/non zero
075e : 4c5e07          >        jmp *           ;failed anyway
                        
0761 : 9002             brvc2   bcc brvc3
0763 : b003                     bcs brvc4
0765 :                  brvc3
                                trap            ;branch carry/no carry
0765 : 4c6507          >        jmp *           ;failed anyway
                        
0768 : 1002             brvc4   bpl brvc5
076a : 3003                     bmi brvc6
076c :                  brvc5
                                trap            ;branch minus/plus
076c : 4c6c07          >        jmp *           ;failed anyway
                        
076f : 7002             brvc6   bvs brvc7
0771 : 5003                     bvc brvc8
0773 :                  brvc7
                                trap            ;branch overflow/no overflow
0773 : 4c7307          >        jmp *           ;failed anyway
                        
0776 :                  brvc8
                                next_test
0776 : ad0002          >            lda test_case   ;previous test
0779 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
077b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
077d : a905            >            lda #test_num   ;*** next tests' number
077f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0782 : a255                     ldx #$55        ;x & y protected
0784 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0786 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
0788 : 48              >            pha         ;use stack to load status
0789 : a901            >            lda #1     ;precharge accu
078b : 28              >            plp
                        
078c : 48                       pha
                                tst_a 1,$ff
078d : 08              >            php         ;save flags
078e : c901            >            cmp #1     ;test result
                       >            trap_ne
0790 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0792 : 68              >            pla         ;load status
0793 : 48              >            pha
                       >            cmp_flag $ff
0794 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0796 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0798 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0799 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
079b : 48              >            pha         ;use stack to load status
079c : a900            >            lda #0     ;precharge accu
079e : 28              >            plp
                        
079f : 48                       pha
                                tst_a 0,0
07a0 : 08              >            php         ;save flags
07a1 : c900            >            cmp #0     ;test result
                       >            trap_ne
07a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a5 : 68              >            pla         ;load status
07a6 : 48              >            pha
                       >            cmp_flag 0
07a7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ab : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07ae : 48              >            pha         ;use stack to load status
07af : a9ff            >            lda #$ff     ;precharge accu
07b1 : 28              >            plp
                        
07b2 : 48                       pha
                                tst_a $ff,$ff
07b3 : 08              >            php         ;save flags
07b4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b8 : 68              >            pla         ;load status
07b9 : 48              >            pha
                       >            cmp_flag $ff
07ba : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07be : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07bf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07c1 : 48              >            pha         ;use stack to load status
07c2 : a901            >            lda #1     ;precharge accu
07c4 : 28              >            plp
                        
07c5 : 48                       pha
                                tst_a 1,0
07c6 : 08              >            php         ;save flags
07c7 : c901            >            cmp #1     ;test result
                       >            trap_ne
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cb : 68              >            pla         ;load status
07cc : 48              >            pha
                       >            cmp_flag 0
07cd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07d2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07d4 : 48              >            pha         ;use stack to load status
07d5 : a900            >            lda #0     ;precharge accu
07d7 : 28              >            plp
                        
07d8 : 48                       pha
                                tst_a 0,$ff
07d9 : 08              >            php         ;save flags
07da : c900            >            cmp #0     ;test result
                       >            trap_ne
07dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07de : 68              >            pla         ;load status
07df : 48              >            pha
                       >            cmp_flag $ff
07e0 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07e4 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07e5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07e7 : 48              >            pha         ;use stack to load status
07e8 : a9ff            >            lda #$ff     ;precharge accu
07ea : 28              >            plp
                        
07eb : 48                       pha
                                tst_a $ff,0
07ec : 08              >            php         ;save flags
07ed : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f1 : 68              >            pla         ;load status
07f2 : 48              >            pha
                       >            cmp_flag 0
07f3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f7 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
07f8 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
07fa : 48              >            pha         ;use stack to load status
07fb : a900            >            lda #0     ;precharge accu
07fd : 28              >            plp
                        
07fe : 68                       pla
                                tst_a $ff,$ff-zero
07ff : 08              >            php         ;save flags
0800 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0804 : 68              >            pla         ;load status
0805 : 48              >            pha
                       >            cmp_flag $ff-zero
0806 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0808 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
080a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
080b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
080d : 48              >            pha         ;use stack to load status
080e : a9ff            >            lda #$ff     ;precharge accu
0810 : 28              >            plp
                        
0811 : 68                       pla
                                tst_a 0,zero
0812 : 08              >            php         ;save flags
0813 : c900            >            cmp #0     ;test result
                       >            trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0817 : 68              >            pla         ;load status
0818 : 48              >            pha
                       >            cmp_flag zero
0819 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
081b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
081d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
081e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0820 : 48              >            pha         ;use stack to load status
0821 : a9fe            >            lda #$fe     ;precharge accu
0823 : 28              >            plp
                        
0824 : 68                       pla
                                tst_a 1,$ff-zero-minus
0825 : 08              >            php         ;save flags
0826 : c901            >            cmp #1     ;test result
                       >            trap_ne
0828 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082a : 68              >            pla         ;load status
082b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
082c : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
082e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0830 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0831 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0833 : 48              >            pha         ;use stack to load status
0834 : a900            >            lda #0     ;precharge accu
0836 : 28              >            plp
                        
0837 : 68                       pla
                                tst_a $ff,minus
0838 : 08              >            php         ;save flags
0839 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
083b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083d : 68              >            pla         ;load status
083e : 48              >            pha
                       >            cmp_flag minus
083f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0841 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0843 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0844 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0846 : 48              >            pha         ;use stack to load status
0847 : a9ff            >            lda #$ff     ;precharge accu
0849 : 28              >            plp
                        
084a : 68                       pla
                                tst_a 0,$ff-minus
084b : 08              >            php         ;save flags
084c : c900            >            cmp #0     ;test result
                       >            trap_ne
084e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0850 : 68              >            pla         ;load status
0851 : 48              >            pha
                       >            cmp_flag $ff-minus
0852 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0854 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0856 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0857 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0859 : 48              >            pha         ;use stack to load status
085a : a9fe            >            lda #$fe     ;precharge accu
085c : 28              >            plp
                        
085d : 68                       pla
                                tst_a 1,0
085e : 08              >            php         ;save flags
085f : c901            >            cmp #1     ;test result
                       >            trap_ne
0861 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0863 : 68              >            pla         ;load status
0864 : 48              >            pha
                       >            cmp_flag 0
0865 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0867 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0869 : 28              >            plp         ;restore status
                        
086a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
086c : d0fe            >        bne *           ;failed not equal (non zero)
                        
086e : c0aa                     cpy #$aa
                                trap_ne
0870 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0872 : ad0002          >            lda test_case   ;previous test
0875 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0877 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0879 : a906            >            lda #test_num   ;*** next tests' number
087b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
087e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0880 : 48              >            pha         ;use stack to load status
0881 : a93c            >            lda #$3c     ;precharge accu
0883 : 28              >            plp
                        
0884 : 49c3                     eor #$c3
                                tst_a $ff,fn
0886 : 08              >            php         ;save flags
0887 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0889 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
088b : 68              >            pla         ;load status
088c : 48              >            pha
                       >            cmp_flag fn
088d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
088f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0891 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0892 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0894 : 48              >            pha         ;use stack to load status
0895 : a9c3            >            lda #$c3     ;precharge accu
0897 : 28              >            plp
                        
0898 : 49c3                     eor #$c3
                                tst_a 0,fz
089a : 08              >            php         ;save flags
089b : c900            >            cmp #0     ;test result
                       >            trap_ne
089d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089f : 68              >            pla         ;load status
08a0 : 48              >            pha
                       >            cmp_flag fz
08a1 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a5 : 28              >            plp         ;restore status
                        
                                next_test
08a6 : ad0002          >            lda test_case   ;previous test
08a9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08ad : a907            >            lda #test_num   ;*** next tests' number
08af : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08b2 : a224                     ldx #$24
08b4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08b6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08b8 : 48              >            pha         ;use stack to load status
08b9 : a918            >            lda #$18     ;precharge accu
08bb : 28              >            plp
                        
08bc : ea                       nop
                                tst_a $18,0
08bd : 08              >            php         ;save flags
08be : c918            >            cmp #$18     ;test result
                       >            trap_ne
08c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c2 : 68              >            pla         ;load status
08c3 : 48              >            pha
                       >            cmp_flag 0
08c4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c8 : 28              >            plp         ;restore status
                        
08c9 : e024                     cpx #$24
                                trap_ne
08cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
08cd : c042                     cpy #$42
                                trap_ne
08cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d1 : a2db                     ldx #$db
08d3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
08d7 : 48              >            pha         ;use stack to load status
08d8 : a9e7            >            lda #$e7     ;precharge accu
08da : 28              >            plp
                        
08db : ea                       nop
                                tst_a $e7,$ff
08dc : 08              >            php         ;save flags
08dd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
08df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e1 : 68              >            pla         ;load status
08e2 : 48              >            pha
                       >            cmp_flag $ff
08e3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08e5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e7 : 28              >            plp         ;restore status
                        
08e8 : e0db                     cpx #$db
                                trap_ne
08ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ec : c0bd                     cpy #$bd
                                trap_ne
08ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08f0 : ad0002          >            lda test_case   ;previous test
08f3 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
08f7 : a908            >            lda #test_num   ;*** next tests' number
08f9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
08fc : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
08fe : 48              >            pha         ;use stack to load status
08ff : 28              >            plp
                        
0900 : a946                     lda #'F'
0902 : a241                     ldx #'A'
0904 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0906 : 4cce36                   jmp test_far
0909 : ea                       nop
090a : ea                       nop
                                trap_ne         ;runover protection
090b : d0fe            >        bne *           ;failed not equal (non zero)
                        
090d : e8                       inx
090e : e8                       inx
090f :                  far_ret 
                                trap_eq         ;returned flags OK?
090f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0911 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0913 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0915 : 50fe            >        bvc *           ;failed overflow clear
                        
0917 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
0919 : d0fe            >        bne *           ;failed not equal (non zero)
                        
091b : e042                     cpx #('A'+1)
                                trap_ne
091d : d0fe            >        bne *           ;failed not equal (non zero)
                        
091f : c04f                     cpy #('R'-3)
                                trap_ne
0921 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0923 : ca                       dex
0924 : c8                       iny
0925 : c8                       iny
0926 : c8                       iny
0927 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
0929 : 4c3209                   jmp test_near
092c : ea                       nop
092d : ea                       nop
                                trap_ne         ;runover protection
092e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0930 : e8                       inx
0931 : e8                       inx
0932 :                  test_near
                                trap_eq         ;passed flags OK?
0932 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0934 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0936 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0938 : 50fe            >        bvc *           ;failed overflow clear
                        
093a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
093c : d0fe            >        bne *           ;failed not equal (non zero)
                        
093e : e041                     cpx #'A'
                                trap_ne
0940 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0942 : c052                     cpy #'R'
                                trap_ne
0944 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0946 : ad0002          >            lda test_case   ;previous test
0949 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
094b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
094d : a909            >            lda #test_num   ;*** next tests' number
094f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0952 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0954 : 48              >            pha         ;use stack to load status
0955 : 28              >            plp
                        
0956 : a949                     lda #'I'
0958 : a24e                     ldx #'N'
095a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
095c : 6cfc36                   jmp (ptr_tst_ind)
095f : ea                       nop
                                trap_ne         ;runover protection
0960 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0962 : 88                       dey
0963 : 88                       dey
0964 :                  ind_ret 
0964 : 08                       php             ;either SP or Y count will fail, if we do not hit
0965 : 88                       dey
0966 : 88                       dey
0967 : 88                       dey
0968 : 28                       plp
                                trap_eq         ;returned flags OK?
0969 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
096b : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
096d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
096f : 50fe            >        bvc *           ;failed overflow clear
                        
0971 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0975 : e04f                     cpx #('N'+1)
                                trap_ne
0977 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0979 : c03e                     cpy #('D'-6)
                                trap_ne
097b : d0fe            >        bne *           ;failed not equal (non zero)
                        
097d : ba                       tsx             ;SP check
097e : e0ff                     cpx #$ff
                                trap_ne
0980 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0982 : ad0002          >            lda test_case   ;previous test
0985 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0987 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
0989 : a90a            >            lda #test_num   ;*** next tests' number
098b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
098e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0990 : 48              >            pha         ;use stack to load status
0991 : 28              >            plp
                        
0992 : a94a                     lda #'J'
0994 : a253                     ldx #'S'
0996 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0998 : 203837                   jsr test_jsr
099a =                  jsr_ret = *-1           ;last address of jsr = return address
099b : 08                       php             ;either SP or Y count will fail, if we do not hit
099c : 88                       dey
099d : 88                       dey
099e : 88                       dey
099f : 28                       plp
                                trap_eq         ;returned flags OK?
09a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09a2 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09a4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09a6 : 50fe            >        bvc *           ;failed overflow clear
                        
09a8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ac : e054                     cpx #('S'+1)
                                trap_ne
09ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b0 : c04c                     cpy #('R'-6)
                                trap_ne
09b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b4 : ba                       tsx             ;sp?
09b5 : e0ff                     cpx #$ff
                                trap_ne
09b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09b9 : ad0002          >            lda test_case   ;previous test
09bc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09c0 : a90b            >            lda #test_num   ;*** next tests' number
09c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                set_stat 0
                       >            load_flag 0
09c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
09c7 : 48              >            pha         ;use stack to load status
09c8 : 28              >            plp
                        
09c9 : a942                     lda #'B'
09cb : a252                     ldx #'R'
09cd : a04b                     ldy #'K'        ;N=0, V=0, Z=0, C=0
09cf : 00                       brk
                            else
                                lda #hi brk_ret ;emulated break
                                pha
                                lda #lo brk_ret
                                pha
                                lda #fao        ;set break & unused on stack
                                pha
                                set_stat intdis
                                lda #'B'
                                ldx #'R'
                                ldy #'K'        ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
09d0 : 88                       dey             ;should not be executed
09d1 :                  brk_ret                 ;address of break return
09d1 : 08                       php             ;either SP or Y count will fail, if we do not hit
09d2 : 88                       dey
09d3 : 88                       dey
09d4 : 88                       dey
09d5 : c9e8                     cmp #('B'^$aa)  ;returned registers OK?
                                trap_ne
09d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09d9 : e053                     cpx #('R'+1)
                                trap_ne
09db : d0fe            >        bne *           ;failed not equal (non zero)
                        
09dd : c045                     cpy #('K'-6)
                                trap_ne
09df : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e1 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
09e2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
09e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e6 : ba                       tsx             ;sp?
09e7 : e0ff                     cpx #$ff
                                trap_ne
09e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09eb : ad0002          >            lda test_case   ;previous test
09ee : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
09f2 : a90c            >            lda #test_num   ;*** next tests' number
09f4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
09f7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09f9 : 48              >            pha         ;use stack to load status
09fa : 28              >            plp
                        
09fb : 18                       clc
                                tst_stat $ff-carry
09fc : 08              >            php         ;save status
09fd : 68              >            pla         ;use stack to retrieve status
09fe : 48              >            pha
                       >            cmp_flag $ff-carry
09ff : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a03 : 28              >            plp         ;restore status
                        
0a04 : 38                       sec
                                tst_stat $ff
0a05 : 08              >            php         ;save status
0a06 : 68              >            pla         ;use stack to retrieve status
0a07 : 48              >            pha
                       >            cmp_flag $ff
0a08 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a0c : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a0d : 58                       cli
                                tst_stat $ff-intdis
0a0e : 08              >            php         ;save status
0a0f : 68              >            pla         ;use stack to retrieve status
0a10 : 48              >            pha
                       >            cmp_flag $ff-intdis
0a11 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a15 : 28              >            plp         ;restore status
                        
0a16 : 78                       sei
                                tst_stat $ff
0a17 : 08              >            php         ;save status
0a18 : 68              >            pla         ;use stack to retrieve status
0a19 : 48              >            pha
                       >            cmp_flag $ff
0a1a : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a1e : 28              >            plp         ;restore status
                        
                            endif
0a1f : d8                       cld
                                tst_stat $ff-decmode
0a20 : 08              >            php         ;save status
0a21 : 68              >            pla         ;use stack to retrieve status
0a22 : 48              >            pha
                       >            cmp_flag $ff-decmode
0a23 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a27 : 28              >            plp         ;restore status
                        
0a28 : f8                       sed
                                tst_stat $ff
0a29 : 08              >            php         ;save status
0a2a : 68              >            pla         ;use stack to retrieve status
0a2b : 48              >            pha
                       >            cmp_flag $ff
0a2c : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a30 : 28              >            plp         ;restore status
                        
0a31 : b8                       clv
                                tst_stat $ff-overfl
0a32 : 08              >            php         ;save status
0a33 : 68              >            pla         ;use stack to retrieve status
0a34 : 48              >            pha
                       >            cmp_flag $ff-overfl
0a35 : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a39 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a3a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a3c : 48              >            pha         ;use stack to load status
0a3d : 28              >            plp
                        
                                tst_stat 0
0a3e : 08              >            php         ;save status
0a3f : 68              >            pla         ;use stack to retrieve status
0a40 : 48              >            pha
                       >            cmp_flag 0
0a41 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a45 : 28              >            plp         ;restore status
                        
0a46 : 38                       sec
                                tst_stat carry
0a47 : 08              >            php         ;save status
0a48 : 68              >            pla         ;use stack to retrieve status
0a49 : 48              >            pha
                       >            cmp_flag carry
0a4a : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a4e : 28              >            plp         ;restore status
                        
0a4f : 18                       clc
                                tst_stat 0  
0a50 : 08              >            php         ;save status
0a51 : 68              >            pla         ;use stack to retrieve status
0a52 : 48              >            pha
                       >            cmp_flag 0  
0a53 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a57 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a58 : 78                       sei
                                tst_stat intdis
0a59 : 08              >            php         ;save status
0a5a : 68              >            pla         ;use stack to retrieve status
0a5b : 48              >            pha
                       >            cmp_flag intdis
0a5c : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a60 : 28              >            plp         ;restore status
                        
0a61 : 58                       cli
                                tst_stat 0
0a62 : 08              >            php         ;save status
0a63 : 68              >            pla         ;use stack to retrieve status
0a64 : 48              >            pha
                       >            cmp_flag 0
0a65 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a69 : 28              >            plp         ;restore status
                        
                            endif  
0a6a : f8                       sed
                                tst_stat decmode
0a6b : 08              >            php         ;save status
0a6c : 68              >            pla         ;use stack to retrieve status
0a6d : 48              >            pha
                       >            cmp_flag decmode
0a6e : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a72 : 28              >            plp         ;restore status
                        
0a73 : d8                       cld
                                tst_stat 0  
0a74 : 08              >            php         ;save status
0a75 : 68              >            pla         ;use stack to retrieve status
0a76 : 48              >            pha
                       >            cmp_flag 0  
0a77 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7b : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0a7c : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0a7e : 48              >            pha         ;use stack to load status
0a7f : 28              >            plp
                        
                                tst_stat overfl
0a80 : 08              >            php         ;save status
0a81 : 68              >            pla         ;use stack to retrieve status
0a82 : 48              >            pha
                       >            cmp_flag overfl
0a83 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a87 : 28              >            plp         ;restore status
                        
0a88 : b8                       clv
                                tst_stat 0
0a89 : 08              >            php         ;save status
0a8a : 68              >            pla         ;use stack to retrieve status
0a8b : 48              >            pha
                       >            cmp_flag 0
0a8c : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a90 : 28              >            plp         ;restore status
                        
                                next_test
0a91 : ad0002          >            lda test_case   ;previous test
0a94 : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0a98 : a90d            >            lda #test_num   ;*** next tests' number
0a9a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0a9d : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0a9f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0aa1 : 48              >            pha         ;use stack to load status
0aa2 : 28              >            plp
                        
0aa3 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0aa4 : 08              >            php         ;save flags
0aa5 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0aa7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa9 : 68              >            pla         ;load status
0aaa : 48              >            pha
                       >            cmp_flag $ff-zero
0aab : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aaf : 28              >            plp         ;restore status
                        
0ab0 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0ab1 : 08              >            php         ;save flags
0ab2 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ab4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab6 : 68              >            pla         ;load status
0ab7 : 48              >            pha
                       >            cmp_flag $ff-minus
0ab8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0abc : 28              >            plp         ;restore status
                        
0abd : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0abe : 08              >            php         ;save flags
0abf : e001            >            cpx #1     ;test result
                       >            trap_ne
0ac1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac3 : 68              >            pla         ;load status
0ac4 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0ac5 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ac7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac9 : 28              >            plp         ;restore status
                        
0aca : ca                       dex             ;00
                                tst_x 0,$ff-minus
0acb : 08              >            php         ;save flags
0acc : e000            >            cpx #0     ;test result
                       >            trap_ne
0ace : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad0 : 68              >            pla         ;load status
0ad1 : 48              >            pha
                       >            cmp_flag $ff-minus
0ad2 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad6 : 28              >            plp         ;restore status
                        
0ad7 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0ad8 : 08              >            php         ;save flags
0ad9 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0adb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0add : 68              >            pla         ;load status
0ade : 48              >            pha
                       >            cmp_flag $ff-zero
0adf : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ae1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae3 : 28              >            plp         ;restore status
                        
0ae4 : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0ae5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ae7 : 48              >            pha         ;use stack to load status
0ae8 : 28              >            plp
                        
0ae9 : e8                       inx             ;ff
                                tst_x $ff,minus
0aea : 08              >            php         ;save flags
0aeb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0aed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aef : 68              >            pla         ;load status
0af0 : 48              >            pha
                       >            cmp_flag minus
0af1 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0af3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af5 : 28              >            plp         ;restore status
                        
0af6 : e8                       inx             ;00
                                tst_x 0,zero
0af7 : 08              >            php         ;save flags
0af8 : e000            >            cpx #0     ;test result
                       >            trap_ne
0afa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0afc : 68              >            pla         ;load status
0afd : 48              >            pha
                       >            cmp_flag zero
0afe : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b02 : 28              >            plp         ;restore status
                        
0b03 : e8                       inx             ;01
                                tst_x 1,0
0b04 : 08              >            php         ;save flags
0b05 : e001            >            cpx #1     ;test result
                       >            trap_ne
0b07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b09 : 68              >            pla         ;load status
0b0a : 48              >            pha
                       >            cmp_flag 0
0b0b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0f : 28              >            plp         ;restore status
                        
0b10 : ca                       dex             ;00
                                tst_x 0,zero
0b11 : 08              >            php         ;save flags
0b12 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b16 : 68              >            pla         ;load status
0b17 : 48              >            pha
                       >            cmp_flag zero
0b18 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1c : 28              >            plp         ;restore status
                        
0b1d : ca                       dex             ;ff
                                tst_x $ff,minus
0b1e : 08              >            php         ;save flags
0b1f : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b23 : 68              >            pla         ;load status
0b24 : 48              >            pha
                       >            cmp_flag minus
0b25 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b29 : 28              >            plp         ;restore status
                        
                        
0b2a : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b2c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b2e : 48              >            pha         ;use stack to load status
0b2f : 28              >            plp
                        
0b30 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b31 : 08              >            php         ;save flags
0b32 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b36 : 68              >            pla         ;load status
0b37 : 48              >            pha
                       >            cmp_flag $ff-zero
0b38 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3c : 28              >            plp         ;restore status
                        
0b3d : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b3e : 08              >            php         ;save flags
0b3f : c000            >            cpy #0     ;test result
                       >            trap_ne
0b41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b43 : 68              >            pla         ;load status
0b44 : 48              >            pha
                       >            cmp_flag $ff-minus
0b45 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b49 : 28              >            plp         ;restore status
                        
0b4a : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0b4b : 08              >            php         ;save flags
0b4c : c001            >            cpy #1     ;test result
                       >            trap_ne
0b4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b50 : 68              >            pla         ;load status
0b51 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b52 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b56 : 28              >            plp         ;restore status
                        
0b57 : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b58 : 08              >            php         ;save flags
0b59 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5d : 68              >            pla         ;load status
0b5e : 48              >            pha
                       >            cmp_flag $ff-minus
0b5f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b63 : 28              >            plp         ;restore status
                        
0b64 : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0b65 : 08              >            php         ;save flags
0b66 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6a : 68              >            pla         ;load status
0b6b : 48              >            pha
                       >            cmp_flag $ff-zero
0b6c : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b70 : 28              >            plp         ;restore status
                        
0b71 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0b72 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b74 : 48              >            pha         ;use stack to load status
0b75 : 28              >            plp
                        
0b76 : c8                       iny             ;ff
                                tst_y $ff,0+minus
0b77 : 08              >            php         ;save flags
0b78 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7c : 68              >            pla         ;load status
0b7d : 48              >            pha
                       >            cmp_flag 0+minus
0b7e : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b82 : 28              >            plp         ;restore status
                        
0b83 : c8                       iny             ;00
                                tst_y 0,zero
0b84 : 08              >            php         ;save flags
0b85 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b89 : 68              >            pla         ;load status
0b8a : 48              >            pha
                       >            cmp_flag zero
0b8b : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8f : 28              >            plp         ;restore status
                        
0b90 : c8                       iny             ;01
                                tst_y 1,0
0b91 : 08              >            php         ;save flags
0b92 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b96 : 68              >            pla         ;load status
0b97 : 48              >            pha
                       >            cmp_flag 0
0b98 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9c : 28              >            plp         ;restore status
                        
0b9d : 88                       dey             ;00
                                tst_y 0,zero
0b9e : 08              >            php         ;save flags
0b9f : c000            >            cpy #0     ;test result
                       >            trap_ne
0ba1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba3 : 68              >            pla         ;load status
0ba4 : 48              >            pha
                       >            cmp_flag zero
0ba5 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ba7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba9 : 28              >            plp         ;restore status
                        
0baa : 88                       dey             ;ff
                                tst_y $ff,minus
0bab : 08              >            php         ;save flags
0bac : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb0 : 68              >            pla         ;load status
0bb1 : 48              >            pha
                       >            cmp_flag minus
0bb2 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb6 : 28              >            plp         ;restore status
                        
                                        
0bb7 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0bb9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0bbb : 48              >            pha         ;use stack to load status
0bbc : 28              >            plp
                        
0bbd : 8a                       txa
                                tst_a $ff,$ff-zero
0bbe : 08              >            php         ;save flags
0bbf : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc3 : 68              >            pla         ;load status
0bc4 : 48              >            pha
                       >            cmp_flag $ff-zero
0bc5 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc9 : 28              >            plp         ;restore status
                        
0bca : 08                       php
0bcb : e8                       inx             ;00
0bcc : 28                       plp
0bcd : 8a                       txa
                                tst_a 0,$ff-minus
0bce : 08              >            php         ;save flags
0bcf : c900            >            cmp #0     ;test result
                       >            trap_ne
0bd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd3 : 68              >            pla         ;load status
0bd4 : 48              >            pha
                       >            cmp_flag $ff-minus
0bd5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd9 : 28              >            plp         ;restore status
                        
0bda : 08                       php
0bdb : e8                       inx             ;01
0bdc : 28                       plp
0bdd : 8a                       txa
                                tst_a 1,$ff-minus-zero
0bde : 08              >            php         ;save flags
0bdf : c901            >            cmp #1     ;test result
                       >            trap_ne
0be1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be3 : 68              >            pla         ;load status
0be4 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0be5 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be9 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0bea : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bec : 48              >            pha         ;use stack to load status
0bed : 28              >            plp
                        
0bee : 8a                       txa
                                tst_a 1,0
0bef : 08              >            php         ;save flags
0bf0 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf4 : 68              >            pla         ;load status
0bf5 : 48              >            pha
                       >            cmp_flag 0
0bf6 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfa : 28              >            plp         ;restore status
                        
0bfb : 08                       php
0bfc : ca                       dex             ;00
0bfd : 28                       plp
0bfe : 8a                       txa
                                tst_a 0,zero
0bff : 08              >            php         ;save flags
0c00 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c04 : 68              >            pla         ;load status
0c05 : 48              >            pha
                       >            cmp_flag zero
0c06 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0a : 28              >            plp         ;restore status
                        
0c0b : 08                       php
0c0c : ca                       dex             ;ff
0c0d : 28                       plp
0c0e : 8a                       txa
                                tst_a $ff,minus
0c0f : 08              >            php         ;save flags
0c10 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c14 : 68              >            pla         ;load status
0c15 : 48              >            pha
                       >            cmp_flag minus
0c16 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1a : 28              >            plp         ;restore status
                        
                                                
0c1b : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0c1d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c1f : 48              >            pha         ;use stack to load status
0c20 : 28              >            plp
                        
0c21 : 98                       tya
                                tst_a $ff,$ff-zero
0c22 : 08              >            php         ;save flags
0c23 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c27 : 68              >            pla         ;load status
0c28 : 48              >            pha
                       >            cmp_flag $ff-zero
0c29 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2d : 28              >            plp         ;restore status
                        
0c2e : 08                       php
0c2f : c8                       iny             ;00
0c30 : 28                       plp
0c31 : 98                       tya
                                tst_a 0,$ff-minus
0c32 : 08              >            php         ;save flags
0c33 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c37 : 68              >            pla         ;load status
0c38 : 48              >            pha
                       >            cmp_flag $ff-minus
0c39 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3d : 28              >            plp         ;restore status
                        
0c3e : 08                       php
0c3f : c8                       iny             ;01
0c40 : 28                       plp
0c41 : 98                       tya
                                tst_a 1,$ff-minus-zero
0c42 : 08              >            php         ;save flags
0c43 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c47 : 68              >            pla         ;load status
0c48 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c49 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4d : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c4e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c50 : 48              >            pha         ;use stack to load status
0c51 : 28              >            plp
                        
0c52 : 98                       tya
                                tst_a 1,0
0c53 : 08              >            php         ;save flags
0c54 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c58 : 68              >            pla         ;load status
0c59 : 48              >            pha
                       >            cmp_flag 0
0c5a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c5e : 28              >            plp         ;restore status
                        
0c5f : 08                       php
0c60 : 88                       dey             ;00
0c61 : 28                       plp
0c62 : 98                       tya
                                tst_a 0,zero
0c63 : 08              >            php         ;save flags
0c64 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c68 : 68              >            pla         ;load status
0c69 : 48              >            pha
                       >            cmp_flag zero
0c6a : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6e : 28              >            plp         ;restore status
                        
0c6f : 08                       php
0c70 : 88                       dey             ;ff
0c71 : 28                       plp
0c72 : 98                       tya
                                tst_a $ff,minus
0c73 : 08              >            php         ;save flags
0c74 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c78 : 68              >            pla         ;load status
0c79 : 48              >            pha
                       >            cmp_flag minus
0c7a : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7e : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0c7f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0c81 : 48                       pha
0c82 : a2ff                     ldx #$ff        ;ff
0c84 : 8a                       txa
0c85 : 28                       plp             
0c86 : a8                       tay
                                tst_y $ff,$ff-zero
0c87 : 08              >            php         ;save flags
0c88 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8c : 68              >            pla         ;load status
0c8d : 48              >            pha
                       >            cmp_flag $ff-zero
0c8e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c92 : 28              >            plp         ;restore status
                        
0c93 : 08                       php
0c94 : e8                       inx             ;00
0c95 : 8a                       txa
0c96 : 28                       plp
0c97 : a8                       tay
                                tst_y 0,$ff-minus
0c98 : 08              >            php         ;save flags
0c99 : c000            >            cpy #0     ;test result
                       >            trap_ne
0c9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9d : 68              >            pla         ;load status
0c9e : 48              >            pha
                       >            cmp_flag $ff-minus
0c9f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ca1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca3 : 28              >            plp         ;restore status
                        
0ca4 : 08                       php
0ca5 : e8                       inx             ;01
0ca6 : 8a                       txa
0ca7 : 28                       plp
0ca8 : a8                       tay
                                tst_y 1,$ff-minus-zero
0ca9 : 08              >            php         ;save flags
0caa : c001            >            cpy #1     ;test result
                       >            trap_ne
0cac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cae : 68              >            pla         ;load status
0caf : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0cb0 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb4 : 28              >            plp         ;restore status
                        
                                load_flag 0
0cb5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0cb7 : 48                       pha
0cb8 : a900                     lda #0
0cba : 8a                       txa
0cbb : 28                       plp
0cbc : a8                       tay
                                tst_y 1,0
0cbd : 08              >            php         ;save flags
0cbe : c001            >            cpy #1     ;test result
                       >            trap_ne
0cc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc2 : 68              >            pla         ;load status
0cc3 : 48              >            pha
                       >            cmp_flag 0
0cc4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc8 : 28              >            plp         ;restore status
                        
0cc9 : 08                       php
0cca : ca                       dex             ;00
0ccb : 8a                       txa
0ccc : 28                       plp
0ccd : a8                       tay
                                tst_y 0,zero
0cce : 08              >            php         ;save flags
0ccf : c000            >            cpy #0     ;test result
                       >            trap_ne
0cd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd3 : 68              >            pla         ;load status
0cd4 : 48              >            pha
                       >            cmp_flag zero
0cd5 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd9 : 28              >            plp         ;restore status
                        
0cda : 08                       php
0cdb : ca                       dex             ;ff
0cdc : 8a                       txa
0cdd : 28                       plp
0cde : a8                       tay
                                tst_y $ff,minus
0cdf : 08              >            php         ;save flags
0ce0 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0ce2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce4 : 68              >            pla         ;load status
0ce5 : 48              >            pha
                       >            cmp_flag minus
0ce6 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cea : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0ceb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0ced : 48                       pha
0cee : a0ff                     ldy #$ff        ;ff
0cf0 : 98                       tya
0cf1 : 28                       plp
0cf2 : aa                       tax
                                tst_x $ff,$ff-zero
0cf3 : 08              >            php         ;save flags
0cf4 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0cf6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf8 : 68              >            pla         ;load status
0cf9 : 48              >            pha
                       >            cmp_flag $ff-zero
0cfa : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cfc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfe : 28              >            plp         ;restore status
                        
0cff : 08                       php
0d00 : c8                       iny             ;00
0d01 : 98                       tya
0d02 : 28                       plp
0d03 : aa                       tax
                                tst_x 0,$ff-minus
0d04 : 08              >            php         ;save flags
0d05 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d09 : 68              >            pla         ;load status
0d0a : 48              >            pha
                       >            cmp_flag $ff-minus
0d0b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0f : 28              >            plp         ;restore status
                        
0d10 : 08                       php
0d11 : c8                       iny             ;01
0d12 : 98                       tya
0d13 : 28                       plp
0d14 : aa                       tax
                                tst_x 1,$ff-minus-zero
0d15 : 08              >            php         ;save flags
0d16 : e001            >            cpx #1     ;test result
                       >            trap_ne
0d18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d1a : 68              >            pla         ;load status
0d1b : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d1c : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d20 : 28              >            plp         ;restore status
                        
                                load_flag 0
0d21 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0d23 : 48                       pha
0d24 : a900                     lda #0          ;preset status
0d26 : 98                       tya
0d27 : 28                       plp
0d28 : aa                       tax
                                tst_x 1,0
0d29 : 08              >            php         ;save flags
0d2a : e001            >            cpx #1     ;test result
                       >            trap_ne
0d2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2e : 68              >            pla         ;load status
0d2f : 48              >            pha
                       >            cmp_flag 0
0d30 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d34 : 28              >            plp         ;restore status
                        
0d35 : 08                       php
0d36 : 88                       dey             ;00
0d37 : 98                       tya
0d38 : 28                       plp
0d39 : aa                       tax
                                tst_x 0,zero
0d3a : 08              >            php         ;save flags
0d3b : e000            >            cpx #0     ;test result
                       >            trap_ne
0d3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d3f : 68              >            pla         ;load status
0d40 : 48              >            pha
                       >            cmp_flag zero
0d41 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d45 : 28              >            plp         ;restore status
                        
0d46 : 08                       php
0d47 : 88                       dey             ;ff
0d48 : 98                       tya
0d49 : 28                       plp
0d4a : aa                       tax
                                tst_x $ff,minus
0d4b : 08              >            php         ;save flags
0d4c : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d50 : 68              >            pla         ;load status
0d51 : 48              >            pha
                       >            cmp_flag minus
0d52 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d56 : 28              >            plp         ;restore status
                        
                                next_test
0d57 : ad0002          >            lda test_case   ;previous test
0d5a : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0d5e : a90e            >            lda #test_num   ;*** next tests' number
0d60 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0d63 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0d65 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d67 : 48              >            pha         ;use stack to load status
0d68 : 28              >            plp
                        
0d69 : 9a                       txs
0d6a : 08                       php
0d6b : ad0101                   lda $101
                                cmp_flag $ff
0d6e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d70 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d72 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d74 : 48              >            pha         ;use stack to load status
0d75 : 28              >            plp
                        
0d76 : 9a                       txs
0d77 : 08                       php
0d78 : ad0101                   lda $101
                                cmp_flag 0
0d7b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d7d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d7f : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0d80 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d82 : 48              >            pha         ;use stack to load status
0d83 : 28              >            plp
                        
0d84 : 9a                       txs
0d85 : 08                       php
0d86 : ad0001                   lda $100
                                cmp_flag $ff
0d89 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d8b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d8d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d8f : 48              >            pha         ;use stack to load status
0d90 : 28              >            plp
                        
0d91 : 9a                       txs
0d92 : 08                       php
0d93 : ad0001                   lda $100
                                cmp_flag 0
0d96 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d98 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d9a : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0d9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d9d : 48              >            pha         ;use stack to load status
0d9e : 28              >            plp
                        
0d9f : 9a                       txs
0da0 : 08                       php
0da1 : adff01                   lda $1ff
                                cmp_flag $ff
0da4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0da6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0da8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0daa : 48              >            pha         ;use stack to load status
0dab : 28              >            plp
                        
0dac : 9a                       txs
0dad : 08                       php
0dae : adff01                   lda $1ff
                                cmp_flag 0
0db1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0db3 : a201                     ldx #1
0db5 : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0db6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0db8 : 48              >            pha         ;use stack to load status
0db9 : 28              >            plp
                        
0dba : ba                       tsx             ;clears Z, N
0dbb : 08                       php             ;sp=00
0dbc : e001                     cpx #1
                                trap_ne
0dbe : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dc0 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0dc3 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dc5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0dc7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dc9 : 48              >            pha         ;use stack to load status
0dca : 28              >            plp
                        
0dcb : ba                       tsx             ;clears N, sets Z
0dcc : 08                       php             ;sp=ff
0dcd : e000                     cpx #0
                                trap_ne
0dcf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd1 : ad0001                   lda $100
                                cmp_flag $ff-minus
0dd4 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dd6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0dd8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dda : 48              >            pha         ;use stack to load status
0ddb : 28              >            plp
                        
0ddc : ba                       tsx             ;clears N, sets Z
0ddd : 08                       php             ;sp=fe
0dde : e0ff                     cpx #$ff
                                trap_ne
0de0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de2 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0de5 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0de7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0de9 : a201                     ldx #1
0deb : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0dec : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dee : 48              >            pha         ;use stack to load status
0def : 28              >            plp
                        
0df0 : ba                       tsx             ;clears Z, N
0df1 : 08                       php             ;sp=00
0df2 : e001                     cpx #1
                                trap_ne
0df4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df6 : ad0101                   lda $101
                                cmp_flag 0
0df9 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dfb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dfd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dff : 48              >            pha         ;use stack to load status
0e00 : 28              >            plp
                        
0e01 : ba                       tsx             ;clears N, sets Z
0e02 : 08                       php             ;sp=ff
0e03 : e000                     cpx #0
                                trap_ne
0e05 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e07 : ad0001                   lda $100
                                cmp_flag zero
0e0a : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e0c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e0e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e10 : 48              >            pha         ;use stack to load status
0e11 : 28              >            plp
                        
0e12 : ba                       tsx             ;clears N, sets Z
0e13 : 08                       php             ;sp=fe
0e14 : e0ff                     cpx #$ff
                                trap_ne
0e16 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e18 : adff01                   lda $1ff
                                cmp_flag minus
0e1b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e1d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e1f : 68                       pla             ;sp=ff
                                next_test
0e20 : ad0002          >            lda test_case   ;previous test
0e23 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0e27 : a90f            >            lda #test_num   ;*** next tests' number
0e29 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e2c : a003                     ldy #3
0e2e :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e2e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e30 : 48              >            pha         ;use stack to load status
0e31 : 28              >            plp
                        
0e32 : b609                     ldx zp1,y
0e34 : 08                       php         ;test stores do not alter flags
0e35 : 8a                       txa
0e36 : 49c3                     eor #$c3
0e38 : 28                       plp
0e39 : 990302                   sta abst,y
0e3c : 08                       php         ;flags after load/store sequence
0e3d : 49c3                     eor #$c3
0e3f : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e42 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e44 : 68                       pla         ;load status
                                eor_flag 0
0e45 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e47 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e4a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e4c : 88                       dey
0e4d : 10df                     bpl tldx                  
                        
0e4f : a003                     ldy #3
0e51 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e51 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e53 : 48              >            pha         ;use stack to load status
0e54 : 28              >            plp
                        
0e55 : b609                     ldx zp1,y
0e57 : 08                       php         ;test stores do not alter flags
0e58 : 8a                       txa
0e59 : 49c3                     eor #$c3
0e5b : 28                       plp
0e5c : 990302                   sta abst,y
0e5f : 08                       php         ;flags after load/store sequence
0e60 : 49c3                     eor #$c3
0e62 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e65 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e67 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e68 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e6a : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e6d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e6f : 88                       dey
0e70 : 10df                     bpl tldx1                  
                        
0e72 : a003                     ldy #3
0e74 :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0e74 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e76 : 48              >            pha         ;use stack to load status
0e77 : 28              >            plp
                        
0e78 : be1702                   ldx abs1,y
0e7b : 08                       php         ;test stores do not alter flags
0e7c : 8a                       txa
0e7d : 49c3                     eor #$c3
0e7f : aa                       tax
0e80 : 28                       plp
0e81 : 9602                     stx zpt,y
0e83 : 08                       php         ;flags after load/store sequence
0e84 : 49c3                     eor #$c3
0e86 : d90900                   cmp zp1,y   ;test result
                                trap_ne
0e89 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e8b : 68                       pla         ;load status
                                eor_flag 0
0e8c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e8e : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e91 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e93 : 88                       dey
0e94 : 10de                     bpl tldx2                  
                        
0e96 : a003                     ldy #3
0e98 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0e98 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e9a : 48              >            pha         ;use stack to load status
0e9b : 28              >            plp
                        
0e9c : be1702                   ldx abs1,y
0e9f : 08                       php         ;test stores do not alter flags
0ea0 : 8a                       txa
0ea1 : 49c3                     eor #$c3
0ea3 : aa                       tax
0ea4 : 28                       plp
0ea5 : 9602                     stx zpt,y
0ea7 : 08                       php         ;flags after load/store sequence
0ea8 : 49c3                     eor #$c3
0eaa : d90900                   cmp zp1,y   ;test result
                                trap_ne
0ead : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eaf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0eb0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0eb2 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0eb5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eb7 : 88                       dey
0eb8 : 10de                     bpl tldx3
                                
0eba : a003                     ldy #3      ;testing store result
0ebc : a200                     ldx #0
0ebe : b90200           tstx    lda zpt,y
0ec1 : 49c3                     eor #$c3
0ec3 : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
0ec6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ec8 : 9602                     stx zpt,y   ;clear                
0eca : b90302                   lda abst,y
0ecd : 49c3                     eor #$c3
0ecf : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0ed2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ed4 : 8a                       txa
0ed5 : 990302                   sta abst,y  ;clear                
0ed8 : 88                       dey
0ed9 : 10e3                     bpl tstx
                                next_test
0edb : ad0002          >            lda test_case   ;previous test
0ede : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ee0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0ee2 : a910            >            lda #test_num   ;*** next tests' number
0ee4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0ee7 : a0fd                     ldy #3+$fa
0ee9 : b60f             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0eeb : 8a                       txa
0eec : 990901                   sta abst-$fa,y      ;no STX abs,y!
0eef : 88                       dey
0ef0 : c0fa                     cpy #$fa
0ef2 : b0f5                     bcs tldx4                  
0ef4 : a0fd                     ldy #3+$fa
0ef6 : be1d01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0ef9 : 9608                     stx zpt-$fa&$ff,y
0efb : 88                       dey
0efc : c0fa                     cpy #$fa
0efe : b0f6                     bcs tldx5                  
0f00 : a003                     ldy #3      ;testing wraparound result
0f02 : a200                     ldx #0
0f04 : b90200           tstx1   lda zpt,y
0f07 : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
0f0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f0c : 9602                     stx zpt,y   ;clear                
0f0e : b90302                   lda abst,y
0f11 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0f14 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f16 : 8a                       txa
0f17 : 990302                   sta abst,y  ;clear                
0f1a : 88                       dey
0f1b : 10e7                     bpl tstx1
                                next_test
0f1d : ad0002          >            lda test_case   ;previous test
0f20 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0f24 : a911            >            lda #test_num   ;*** next tests' number
0f26 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0f29 : a203                     ldx #3
0f2b :                  tldy    
                                set_stat 0
                       >            load_flag 0
0f2b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f2d : 48              >            pha         ;use stack to load status
0f2e : 28              >            plp
                        
0f2f : b409                     ldy zp1,x
0f31 : 08                       php         ;test stores do not alter flags
0f32 : 98                       tya
0f33 : 49c3                     eor #$c3
0f35 : 28                       plp
0f36 : 9d0302                   sta abst,x
0f39 : 08                       php         ;flags after load/store sequence
0f3a : 49c3                     eor #$c3
0f3c : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f41 : 68                       pla         ;load status
                                eor_flag 0
0f42 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f44 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f47 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f49 : ca                       dex
0f4a : 10df                     bpl tldy                  
                        
0f4c : a203                     ldx #3
0f4e :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f50 : 48              >            pha         ;use stack to load status
0f51 : 28              >            plp
                        
0f52 : b409                     ldy zp1,x
0f54 : 08                       php         ;test stores do not alter flags
0f55 : 98                       tya
0f56 : 49c3                     eor #$c3
0f58 : 28                       plp
0f59 : 9d0302                   sta abst,x
0f5c : 08                       php         ;flags after load/store sequence
0f5d : 49c3                     eor #$c3
0f5f : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f62 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f64 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f65 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f67 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f6a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f6c : ca                       dex
0f6d : 10df                     bpl tldy1                  
                        
0f6f : a203                     ldx #3
0f71 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0f71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f73 : 48              >            pha         ;use stack to load status
0f74 : 28              >            plp
                        
0f75 : bc1702                   ldy abs1,x
0f78 : 08                       php         ;test stores do not alter flags
0f79 : 98                       tya
0f7a : 49c3                     eor #$c3
0f7c : a8                       tay
0f7d : 28                       plp
0f7e : 9402                     sty zpt,x
0f80 : 08                       php         ;flags after load/store sequence
0f81 : 49c3                     eor #$c3
0f83 : d509                     cmp zp1,x   ;test result
                                trap_ne
0f85 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f87 : 68                       pla         ;load status
                                eor_flag 0
0f88 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f8a : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f8d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f8f : ca                       dex
0f90 : 10df                     bpl tldy2                  
                        
0f92 : a203                     ldx #3
0f94 :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0f94 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f96 : 48              >            pha         ;use stack to load status
0f97 : 28              >            plp
                        
0f98 : bc1702                   ldy abs1,x
0f9b : 08                       php         ;test stores do not alter flags
0f9c : 98                       tya
0f9d : 49c3                     eor #$c3
0f9f : a8                       tay
0fa0 : 28                       plp
0fa1 : 9402                     sty zpt,x
0fa3 : 08                       php         ;flags after load/store sequence
0fa4 : 49c3                     eor #$c3
0fa6 : d509                     cmp zp1,x   ;test result
                                trap_ne
0fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0faa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fab : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fad : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fb0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fb2 : ca                       dex
0fb3 : 10df                     bpl tldy3
                        
0fb5 : a203                     ldx #3      ;testing store result
0fb7 : a000                     ldy #0
0fb9 : b502             tsty    lda zpt,x
0fbb : 49c3                     eor #$c3
0fbd : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0fbf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fc1 : 9402                     sty zpt,x   ;clear                
0fc3 : bd0302                   lda abst,x
0fc6 : 49c3                     eor #$c3
0fc8 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fcb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fcd : 8a                       txa
0fce : 9d0302                   sta abst,x  ;clear                
0fd1 : ca                       dex
0fd2 : 10e5                     bpl tsty
                                next_test
0fd4 : ad0002          >            lda test_case   ;previous test
0fd7 : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fd9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0fdb : a912            >            lda #test_num   ;*** next tests' number
0fdd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0fe0 : a2fd                     ldx #3+$fa
0fe2 : b40f             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0fe4 : 98                       tya
0fe5 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0fe8 : ca                       dex
0fe9 : e0fa                     cpx #$fa
0feb : b0f5                     bcs tldy4                  
0fed : a2fd                     ldx #3+$fa
0fef : bc1d01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0ff2 : 9408                     sty zpt-$fa&$ff,x
0ff4 : ca                       dex
0ff5 : e0fa                     cpx #$fa
0ff7 : b0f6                     bcs tldy5                  
0ff9 : a203                     ldx #3      ;testing wraparound result
0ffb : a000                     ldy #0
0ffd : b502             tsty1   lda zpt,x
0fff : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1001 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1003 : 9402                     sty zpt,x   ;clear                
1005 : bd0302                   lda abst,x
1008 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
100b : d0fe            >        bne *           ;failed not equal (non zero)
                        
100d : 8a                       txa
100e : 9d0302                   sta abst,x  ;clear                
1011 : ca                       dex
1012 : 10e9                     bpl tsty1
                                next_test
1014 : ad0002          >            lda test_case   ;previous test
1017 : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1019 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
101b : a913            >            lda #test_num   ;*** next tests' number
101d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1020 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1022 : 48              >            pha         ;use stack to load status
1023 : 28              >            plp
                        
1024 : a609                     ldx zp1
1026 : 08                       php         ;test stores do not alter flags
1027 : 8a                       txa
1028 : 49c3                     eor #$c3
102a : aa                       tax
102b : 28                       plp
102c : 8e0302                   stx abst
102f : 08                       php         ;flags after load/store sequence
1030 : 49c3                     eor #$c3
1032 : aa                       tax
1033 : e0c3                     cpx #$c3    ;test result
                                trap_ne
1035 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1037 : 68                       pla         ;load status
                                eor_flag 0
1038 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
103a : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
103d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
103f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1041 : 48              >            pha         ;use stack to load status
1042 : 28              >            plp
                        
1043 : a60a                     ldx zp1+1
1045 : 08                       php         ;test stores do not alter flags
1046 : 8a                       txa
1047 : 49c3                     eor #$c3
1049 : aa                       tax
104a : 28                       plp
104b : 8e0402                   stx abst+1
104e : 08                       php         ;flags after load/store sequence
104f : 49c3                     eor #$c3
1051 : aa                       tax
1052 : e082                     cpx #$82    ;test result
                                trap_ne
1054 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1056 : 68                       pla         ;load status
                                eor_flag 0
1057 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1059 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
105c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
105e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1060 : 48              >            pha         ;use stack to load status
1061 : 28              >            plp
                        
1062 : a60b                     ldx zp1+2
1064 : 08                       php         ;test stores do not alter flags
1065 : 8a                       txa
1066 : 49c3                     eor #$c3
1068 : aa                       tax
1069 : 28                       plp
106a : 8e0502                   stx abst+2
106d : 08                       php         ;flags after load/store sequence
106e : 49c3                     eor #$c3
1070 : aa                       tax
1071 : e041                     cpx #$41    ;test result
                                trap_ne
1073 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1075 : 68                       pla         ;load status
                                eor_flag 0
1076 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1078 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
107b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
107d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
107f : 48              >            pha         ;use stack to load status
1080 : 28              >            plp
                        
1081 : a60c                     ldx zp1+3
1083 : 08                       php         ;test stores do not alter flags
1084 : 8a                       txa
1085 : 49c3                     eor #$c3
1087 : aa                       tax
1088 : 28                       plp
1089 : 8e0602                   stx abst+3
108c : 08                       php         ;flags after load/store sequence
108d : 49c3                     eor #$c3
108f : aa                       tax
1090 : e000                     cpx #0      ;test result
                                trap_ne
1092 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1094 : 68                       pla         ;load status
                                eor_flag 0
1095 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1097 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
109a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
109c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
109e : 48              >            pha         ;use stack to load status
109f : 28              >            plp
                        
10a0 : a609                     ldx zp1  
10a2 : 08                       php         ;test stores do not alter flags
10a3 : 8a                       txa
10a4 : 49c3                     eor #$c3
10a6 : aa                       tax
10a7 : 28                       plp
10a8 : 8e0302                   stx abst  
10ab : 08                       php         ;flags after load/store sequence
10ac : 49c3                     eor #$c3
10ae : aa                       tax
10af : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
10b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10b3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10b4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10b6 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
10b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10bd : 48              >            pha         ;use stack to load status
10be : 28              >            plp
                        
10bf : a60a                     ldx zp1+1
10c1 : 08                       php         ;test stores do not alter flags
10c2 : 8a                       txa
10c3 : 49c3                     eor #$c3
10c5 : aa                       tax
10c6 : 28                       plp
10c7 : 8e0402                   stx abst+1
10ca : 08                       php         ;flags after load/store sequence
10cb : 49c3                     eor #$c3
10cd : aa                       tax
10ce : e082                     cpx #$82    ;test result
                                trap_ne
10d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10d2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10d3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10d5 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
10d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10da : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10dc : 48              >            pha         ;use stack to load status
10dd : 28              >            plp
                        
10de : a60b                     ldx zp1+2
10e0 : 08                       php         ;test stores do not alter flags
10e1 : 8a                       txa
10e2 : 49c3                     eor #$c3
10e4 : aa                       tax
10e5 : 28                       plp
10e6 : 8e0502                   stx abst+2
10e9 : 08                       php         ;flags after load/store sequence
10ea : 49c3                     eor #$c3
10ec : aa                       tax
10ed : e041                     cpx #$41    ;test result
                                trap_ne     ;
10ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
10f1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10f2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10f4 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
10f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10f9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10fb : 48              >            pha         ;use stack to load status
10fc : 28              >            plp
                        
10fd : a60c                     ldx zp1+3
10ff : 08                       php         ;test stores do not alter flags
1100 : 8a                       txa
1101 : 49c3                     eor #$c3
1103 : aa                       tax
1104 : 28                       plp
1105 : 8e0602                   stx abst+3
1108 : 08                       php         ;flags after load/store sequence
1109 : 49c3                     eor #$c3
110b : aa                       tax
110c : e000                     cpx #0      ;test result
                                trap_ne
110e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1110 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1111 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1113 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1116 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
1118 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
111a : 48              >            pha         ;use stack to load status
111b : 28              >            plp
                        
111c : ae1702                   ldx abs1  
111f : 08                       php         ;test stores do not alter flags
1120 : 8a                       txa
1121 : 49c3                     eor #$c3
1123 : aa                       tax
1124 : 28                       plp
1125 : 8602                     stx zpt  
1127 : 08                       php         ;flags after load/store sequence
1128 : 49c3                     eor #$c3
112a : c509                     cmp zp1     ;test result
                                trap_ne
112c : d0fe            >        bne *           ;failed not equal (non zero)
                        
112e : 68                       pla         ;load status
                                eor_flag 0
112f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1131 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1134 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1136 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1138 : 48              >            pha         ;use stack to load status
1139 : 28              >            plp
                        
113a : ae1802                   ldx abs1+1
113d : 08                       php         ;test stores do not alter flags
113e : 8a                       txa
113f : 49c3                     eor #$c3
1141 : aa                       tax
1142 : 28                       plp
1143 : 8603                     stx zpt+1
1145 : 08                       php         ;flags after load/store sequence
1146 : 49c3                     eor #$c3
1148 : c50a                     cmp zp1+1   ;test result
                                trap_ne
114a : d0fe            >        bne *           ;failed not equal (non zero)
                        
114c : 68                       pla         ;load status
                                eor_flag 0
114d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
114f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1152 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1154 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1156 : 48              >            pha         ;use stack to load status
1157 : 28              >            plp
                        
1158 : ae1902                   ldx abs1+2
115b : 08                       php         ;test stores do not alter flags
115c : 8a                       txa
115d : 49c3                     eor #$c3
115f : aa                       tax
1160 : 28                       plp
1161 : 8604                     stx zpt+2
1163 : 08                       php         ;flags after load/store sequence
1164 : 49c3                     eor #$c3
1166 : c50b                     cmp zp1+2   ;test result
                                trap_ne
1168 : d0fe            >        bne *           ;failed not equal (non zero)
                        
116a : 68                       pla         ;load status
                                eor_flag 0
116b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
116d : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1170 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1172 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1174 : 48              >            pha         ;use stack to load status
1175 : 28              >            plp
                        
1176 : ae1a02                   ldx abs1+3
1179 : 08                       php         ;test stores do not alter flags
117a : 8a                       txa
117b : 49c3                     eor #$c3
117d : aa                       tax
117e : 28                       plp
117f : 8605                     stx zpt+3
1181 : 08                       php         ;flags after load/store sequence
1182 : 49c3                     eor #$c3
1184 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1186 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1188 : 68                       pla         ;load status
                                eor_flag 0
1189 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
118b : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
118e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1190 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1192 : 48              >            pha         ;use stack to load status
1193 : 28              >            plp
                        
1194 : ae1702                   ldx abs1  
1197 : 08                       php         ;test stores do not alter flags
1198 : 8a                       txa
1199 : 49c3                     eor #$c3
119b : aa                       tax
119c : 28                       plp
119d : 8602                     stx zpt  
119f : 08                       php         ;flags after load/store sequence
11a0 : 49c3                     eor #$c3
11a2 : aa                       tax
11a3 : e409                     cpx zp1     ;test result
                                trap_ne
11a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11a7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11a8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11aa : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
11ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11af : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11b1 : 48              >            pha         ;use stack to load status
11b2 : 28              >            plp
                        
11b3 : ae1802                   ldx abs1+1
11b6 : 08                       php         ;test stores do not alter flags
11b7 : 8a                       txa
11b8 : 49c3                     eor #$c3
11ba : aa                       tax
11bb : 28                       plp
11bc : 8603                     stx zpt+1
11be : 08                       php         ;flags after load/store sequence
11bf : 49c3                     eor #$c3
11c1 : aa                       tax
11c2 : e40a                     cpx zp1+1   ;test result
                                trap_ne
11c4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11c6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11c7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11c9 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
11cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11ce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11d0 : 48              >            pha         ;use stack to load status
11d1 : 28              >            plp
                        
11d2 : ae1902                   ldx abs1+2
11d5 : 08                       php         ;test stores do not alter flags
11d6 : 8a                       txa
11d7 : 49c3                     eor #$c3
11d9 : aa                       tax
11da : 28                       plp
11db : 8604                     stx zpt+2
11dd : 08                       php         ;flags after load/store sequence
11de : 49c3                     eor #$c3
11e0 : aa                       tax
11e1 : e40b                     cpx zp1+2   ;test result
                                trap_ne
11e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11e5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11e6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11e8 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
11eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11ef : 48              >            pha         ;use stack to load status
11f0 : 28              >            plp
                        
11f1 : ae1a02                   ldx abs1+3
11f4 : 08                       php         ;test stores do not alter flags
11f5 : 8a                       txa
11f6 : 49c3                     eor #$c3
11f8 : aa                       tax
11f9 : 28                       plp
11fa : 8605                     stx zpt+3
11fc : 08                       php         ;flags after load/store sequence
11fd : 49c3                     eor #$c3
11ff : aa                       tax
1200 : e40c                     cpx zp1+3   ;test result
                                trap_ne
1202 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1204 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1205 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1207 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
120a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
120c : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
120e : 48              >            pha         ;use stack to load status
120f : 28              >            plp
                        
1210 : a2c3                     ldx #$c3
1212 : 08                       php
1213 : ec1702                   cpx abs1    ;test result
                                trap_ne
1216 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1218 : 68                       pla         ;load status
                                eor_flag 0
1219 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
121b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
121e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1220 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1222 : 48              >            pha         ;use stack to load status
1223 : 28              >            plp
                        
1224 : a282                     ldx #$82
1226 : 08                       php
1227 : ec1802                   cpx abs1+1  ;test result
                                trap_ne
122a : d0fe            >        bne *           ;failed not equal (non zero)
                        
122c : 68                       pla         ;load status
                                eor_flag 0
122d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
122f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1232 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1234 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1236 : 48              >            pha         ;use stack to load status
1237 : 28              >            plp
                        
1238 : a241                     ldx #$41
123a : 08                       php
123b : ec1902                   cpx abs1+2  ;test result
                                trap_ne
123e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1240 : 68                       pla         ;load status
                                eor_flag 0
1241 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1243 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1246 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1248 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
124a : 48              >            pha         ;use stack to load status
124b : 28              >            plp
                        
124c : a200                     ldx #0
124e : 08                       php
124f : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
1252 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1254 : 68                       pla         ;load status
                                eor_flag 0
1255 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1257 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
125a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
125c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
125e : 48              >            pha         ;use stack to load status
125f : 28              >            plp
                        
1260 : a2c3                     ldx #$c3  
1262 : 08                       php
1263 : ec1702                   cpx abs1    ;test result
                                trap_ne
1266 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1268 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1269 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
126b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
126e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1270 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1272 : 48              >            pha         ;use stack to load status
1273 : 28              >            plp
                        
1274 : a282                     ldx #$82
1276 : 08                       php
1277 : ec1802                   cpx abs1+1  ;test result
                                trap_ne
127a : d0fe            >        bne *           ;failed not equal (non zero)
                        
127c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
127d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
127f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1282 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1284 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1286 : 48              >            pha         ;use stack to load status
1287 : 28              >            plp
                        
1288 : a241                     ldx #$41
128a : 08                       php
128b : ec1902                   cpx abs1+2  ;test result
                                trap_ne
128e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1290 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1291 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1293 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1296 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1298 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
129a : 48              >            pha         ;use stack to load status
129b : 28              >            plp
                        
129c : a200                     ldx #0
129e : 08                       php
129f : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
12a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12a5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12a7 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
12aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
12ac : a200                     ldx #0
12ae : a502                     lda zpt  
12b0 : 49c3                     eor #$c3
12b2 : c509                     cmp zp1  
                                trap_ne     ;store to zp data
12b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b6 : 8602                     stx zpt     ;clear                
12b8 : ad0302                   lda abst  
12bb : 49c3                     eor #$c3
12bd : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
12c0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12c2 : 8e0302                   stx abst    ;clear                
12c5 : a503                     lda zpt+1
12c7 : 49c3                     eor #$c3
12c9 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
12cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
12cd : 8603                     stx zpt+1   ;clear                
12cf : ad0402                   lda abst+1
12d2 : 49c3                     eor #$c3
12d4 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
12d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d9 : 8e0402                   stx abst+1  ;clear                
12dc : a504                     lda zpt+2
12de : 49c3                     eor #$c3
12e0 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
12e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e4 : 8604                     stx zpt+2   ;clear                
12e6 : ad0502                   lda abst+2
12e9 : 49c3                     eor #$c3
12eb : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
12ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
12f0 : 8e0502                   stx abst+2  ;clear                
12f3 : a505                     lda zpt+3
12f5 : 49c3                     eor #$c3
12f7 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
12f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fb : 8605                     stx zpt+3   ;clear                
12fd : ad0602                   lda abst+3
1300 : 49c3                     eor #$c3
1302 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1305 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1307 : 8e0602                   stx abst+3  ;clear                
                                next_test
130a : ad0002          >            lda test_case   ;previous test
130d : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
130f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
1311 : a914            >            lda #test_num   ;*** next tests' number
1313 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
1316 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1318 : 48              >            pha         ;use stack to load status
1319 : 28              >            plp
                        
131a : a409                     ldy zp1  
131c : 08                       php         ;test stores do not alter flags
131d : 98                       tya
131e : 49c3                     eor #$c3
1320 : a8                       tay
1321 : 28                       plp
1322 : 8c0302                   sty abst  
1325 : 08                       php         ;flags after load/store sequence
1326 : 49c3                     eor #$c3
1328 : a8                       tay
1329 : c0c3                     cpy #$c3    ;test result
                                trap_ne
132b : d0fe            >        bne *           ;failed not equal (non zero)
                        
132d : 68                       pla         ;load status
                                eor_flag 0
132e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1330 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1333 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1335 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1337 : 48              >            pha         ;use stack to load status
1338 : 28              >            plp
                        
1339 : a40a                     ldy zp1+1
133b : 08                       php         ;test stores do not alter flags
133c : 98                       tya
133d : 49c3                     eor #$c3
133f : a8                       tay
1340 : 28                       plp
1341 : 8c0402                   sty abst+1
1344 : 08                       php         ;flags after load/store sequence
1345 : 49c3                     eor #$c3
1347 : a8                       tay
1348 : c082                     cpy #$82    ;test result
                                trap_ne
134a : d0fe            >        bne *           ;failed not equal (non zero)
                        
134c : 68                       pla         ;load status
                                eor_flag 0
134d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
134f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1352 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1354 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1356 : 48              >            pha         ;use stack to load status
1357 : 28              >            plp
                        
1358 : a40b                     ldy zp1+2
135a : 08                       php         ;test stores do not alter flags
135b : 98                       tya
135c : 49c3                     eor #$c3
135e : a8                       tay
135f : 28                       plp
1360 : 8c0502                   sty abst+2
1363 : 08                       php         ;flags after load/store sequence
1364 : 49c3                     eor #$c3
1366 : a8                       tay
1367 : c041                     cpy #$41    ;test result
                                trap_ne
1369 : d0fe            >        bne *           ;failed not equal (non zero)
                        
136b : 68                       pla         ;load status
                                eor_flag 0
136c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
136e : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1371 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1373 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1375 : 48              >            pha         ;use stack to load status
1376 : 28              >            plp
                        
1377 : a40c                     ldy zp1+3
1379 : 08                       php         ;test stores do not alter flags
137a : 98                       tya
137b : 49c3                     eor #$c3
137d : a8                       tay
137e : 28                       plp
137f : 8c0602                   sty abst+3
1382 : 08                       php         ;flags after load/store sequence
1383 : 49c3                     eor #$c3
1385 : a8                       tay
1386 : c000                     cpy #0      ;test result
                                trap_ne
1388 : d0fe            >        bne *           ;failed not equal (non zero)
                        
138a : 68                       pla         ;load status
                                eor_flag 0
138b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
138d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1390 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1392 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1394 : 48              >            pha         ;use stack to load status
1395 : 28              >            plp
                        
1396 : a409                     ldy zp1  
1398 : 08                       php         ;test stores do not alter flags
1399 : 98                       tya
139a : 49c3                     eor #$c3
139c : a8                       tay
139d : 28                       plp
139e : 8c0302                   sty abst  
13a1 : 08                       php         ;flags after load/store sequence
13a2 : 49c3                     eor #$c3
13a4 : a8                       tay
13a5 : c0c3                     cpy #$c3    ;test result
                                trap_ne
13a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13a9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13aa : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13ac : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
13af : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13b1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13b3 : 48              >            pha         ;use stack to load status
13b4 : 28              >            plp
                        
13b5 : a40a                     ldy zp1+1
13b7 : 08                       php         ;test stores do not alter flags
13b8 : 98                       tya
13b9 : 49c3                     eor #$c3
13bb : a8                       tay
13bc : 28                       plp
13bd : 8c0402                   sty abst+1
13c0 : 08                       php         ;flags after load/store sequence
13c1 : 49c3                     eor #$c3
13c3 : a8                       tay
13c4 : c082                     cpy #$82   ;test result
                                trap_ne
13c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13c8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13c9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13cb : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
13ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13d2 : 48              >            pha         ;use stack to load status
13d3 : 28              >            plp
                        
13d4 : a40b                     ldy zp1+2
13d6 : 08                       php         ;test stores do not alter flags
13d7 : 98                       tya
13d8 : 49c3                     eor #$c3
13da : a8                       tay
13db : 28                       plp
13dc : 8c0502                   sty abst+2
13df : 08                       php         ;flags after load/store sequence
13e0 : 49c3                     eor #$c3
13e2 : a8                       tay
13e3 : c041                     cpy #$41    ;test result
                                trap_ne
13e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13e7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13e8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13ea : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
13ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13f1 : 48              >            pha         ;use stack to load status
13f2 : 28              >            plp
                        
13f3 : a40c                     ldy zp1+3
13f5 : 08                       php         ;test stores do not alter flags
13f6 : 98                       tya
13f7 : 49c3                     eor #$c3
13f9 : a8                       tay
13fa : 28                       plp
13fb : 8c0602                   sty abst+3
13fe : 08                       php         ;flags after load/store sequence
13ff : 49c3                     eor #$c3
1401 : a8                       tay
1402 : c000                     cpy #0      ;test result
                                trap_ne
1404 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1406 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1407 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1409 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
140c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
140e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1410 : 48              >            pha         ;use stack to load status
1411 : 28              >            plp
                        
1412 : ac1702                   ldy abs1  
1415 : 08                       php         ;test stores do not alter flags
1416 : 98                       tya
1417 : 49c3                     eor #$c3
1419 : a8                       tay
141a : 28                       plp
141b : 8402                     sty zpt  
141d : 08                       php         ;flags after load/store sequence
141e : 49c3                     eor #$c3
1420 : a8                       tay
1421 : c409                     cpy zp1     ;test result
                                trap_ne
1423 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1425 : 68                       pla         ;load status
                                eor_flag 0
1426 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1428 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
142b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
142d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
142f : 48              >            pha         ;use stack to load status
1430 : 28              >            plp
                        
1431 : ac1802                   ldy abs1+1
1434 : 08                       php         ;test stores do not alter flags
1435 : 98                       tya
1436 : 49c3                     eor #$c3
1438 : a8                       tay
1439 : 28                       plp
143a : 8403                     sty zpt+1
143c : 08                       php         ;flags after load/store sequence
143d : 49c3                     eor #$c3
143f : a8                       tay
1440 : c40a                     cpy zp1+1   ;test result
                                trap_ne
1442 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1444 : 68                       pla         ;load status
                                eor_flag 0
1445 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1447 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
144a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
144c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
144e : 48              >            pha         ;use stack to load status
144f : 28              >            plp
                        
1450 : ac1902                   ldy abs1+2
1453 : 08                       php         ;test stores do not alter flags
1454 : 98                       tya
1455 : 49c3                     eor #$c3
1457 : a8                       tay
1458 : 28                       plp
1459 : 8404                     sty zpt+2
145b : 08                       php         ;flags after load/store sequence
145c : 49c3                     eor #$c3
145e : a8                       tay
145f : c40b                     cpy zp1+2   ;test result
                                trap_ne
1461 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1463 : 68                       pla         ;load status
                                eor_flag 0
1464 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1466 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1469 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
146b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
146d : 48              >            pha         ;use stack to load status
146e : 28              >            plp
                        
146f : ac1a02                   ldy abs1+3
1472 : 08                       php         ;test stores do not alter flags
1473 : 98                       tya
1474 : 49c3                     eor #$c3
1476 : a8                       tay
1477 : 28                       plp
1478 : 8405                     sty zpt+3
147a : 08                       php         ;flags after load/store sequence
147b : 49c3                     eor #$c3
147d : a8                       tay
147e : c40c                     cpy zp1+3   ;test result
                                trap_ne
1480 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1482 : 68                       pla         ;load status
                                eor_flag 0
1483 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1485 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1488 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
148a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
148c : 48              >            pha         ;use stack to load status
148d : 28              >            plp
                        
148e : ac1702                   ldy abs1  
1491 : 08                       php         ;test stores do not alter flags
1492 : 98                       tya
1493 : 49c3                     eor #$c3
1495 : a8                       tay
1496 : 28                       plp
1497 : 8402                     sty zpt  
1499 : 08                       php         ;flags after load/store sequence
149a : 49c3                     eor #$c3
149c : a8                       tay
149d : c509                     cmp zp1     ;test result
                                trap_ne
149f : d0fe            >        bne *           ;failed not equal (non zero)
                        
14a1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14a2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14a4 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
14a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14ab : 48              >            pha         ;use stack to load status
14ac : 28              >            plp
                        
14ad : ac1802                   ldy abs1+1
14b0 : 08                       php         ;test stores do not alter flags
14b1 : 98                       tya
14b2 : 49c3                     eor #$c3
14b4 : a8                       tay
14b5 : 28                       plp
14b6 : 8403                     sty zpt+1
14b8 : 08                       php         ;flags after load/store sequence
14b9 : 49c3                     eor #$c3
14bb : a8                       tay
14bc : c50a                     cmp zp1+1   ;test result
                                trap_ne
14be : d0fe            >        bne *           ;failed not equal (non zero)
                        
14c0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14c1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14c3 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
14c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14c8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14ca : 48              >            pha         ;use stack to load status
14cb : 28              >            plp
                        
14cc : ac1902                   ldy abs1+2
14cf : 08                       php         ;test stores do not alter flags
14d0 : 98                       tya
14d1 : 49c3                     eor #$c3
14d3 : a8                       tay
14d4 : 28                       plp
14d5 : 8404                     sty zpt+2
14d7 : 08                       php         ;flags after load/store sequence
14d8 : 49c3                     eor #$c3
14da : a8                       tay
14db : c50b                     cmp zp1+2   ;test result
                                trap_ne
14dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
14df : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14e0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14e2 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
14e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14e7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14e9 : 48              >            pha         ;use stack to load status
14ea : 28              >            plp
                        
14eb : ac1a02                   ldy abs1+3
14ee : 08                       php         ;test stores do not alter flags
14ef : 98                       tya
14f0 : 49c3                     eor #$c3
14f2 : a8                       tay
14f3 : 28                       plp
14f4 : 8405                     sty zpt+3
14f6 : 08                       php         ;flags after load/store sequence
14f7 : 49c3                     eor #$c3
14f9 : a8                       tay
14fa : c50c                     cmp zp1+3   ;test result
                                trap_ne
14fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
14fe : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14ff : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1501 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1504 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
1506 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1508 : 48              >            pha         ;use stack to load status
1509 : 28              >            plp
                        
150a : a0c3                     ldy #$c3  
150c : 08                       php
150d : cc1702                   cpy abs1    ;test result
                                trap_ne
1510 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1512 : 68                       pla         ;load status
                                eor_flag 0
1513 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1515 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1518 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
151a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
151c : 48              >            pha         ;use stack to load status
151d : 28              >            plp
                        
151e : a082                     ldy #$82
1520 : 08                       php
1521 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
1524 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1526 : 68                       pla         ;load status
                                eor_flag 0
1527 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1529 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
152c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
152e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1530 : 48              >            pha         ;use stack to load status
1531 : 28              >            plp
                        
1532 : a041                     ldy #$41
1534 : 08                       php
1535 : cc1902                   cpy abs1+2  ;test result
                                trap_ne
1538 : d0fe            >        bne *           ;failed not equal (non zero)
                        
153a : 68                       pla         ;load status
                                eor_flag 0
153b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
153d : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1540 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1542 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1544 : 48              >            pha         ;use stack to load status
1545 : 28              >            plp
                        
1546 : a000                     ldy #0
1548 : 08                       php
1549 : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
154c : d0fe            >        bne *           ;failed not equal (non zero)
                        
154e : 68                       pla         ;load status
                                eor_flag 0
154f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1551 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1554 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1556 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1558 : 48              >            pha         ;use stack to load status
1559 : 28              >            plp
                        
155a : a0c3                     ldy #$c3  
155c : 08                       php
155d : cc1702                   cpy abs1    ;test result
                                trap_ne
1560 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1562 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1563 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1565 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1568 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
156a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
156c : 48              >            pha         ;use stack to load status
156d : 28              >            plp
                        
156e : a082                     ldy #$82
1570 : 08                       php
1571 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
1574 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1576 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1577 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1579 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
157c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
157e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1580 : 48              >            pha         ;use stack to load status
1581 : 28              >            plp
                        
1582 : a041                     ldy #$41
1584 : 08                       php
1585 : cc1902                   cpy abs1+2   ;test result
                                trap_ne
1588 : d0fe            >        bne *           ;failed not equal (non zero)
                        
158a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
158b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
158d : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1590 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1592 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1594 : 48              >            pha         ;use stack to load status
1595 : 28              >            plp
                        
1596 : a000                     ldy #0
1598 : 08                       php
1599 : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
159c : d0fe            >        bne *           ;failed not equal (non zero)
                        
159e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
159f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15a1 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
15a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
15a6 : a000                     ldy #0
15a8 : a502                     lda zpt  
15aa : 49c3                     eor #$c3
15ac : c509                     cmp zp1  
                                trap_ne     ;store to zp   data
15ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
15b0 : 8402                     sty zpt     ;clear                
15b2 : ad0302                   lda abst  
15b5 : 49c3                     eor #$c3
15b7 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs   data
15ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
15bc : 8c0302                   sty abst    ;clear                
15bf : a503                     lda zpt+1
15c1 : 49c3                     eor #$c3
15c3 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
15c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15c7 : 8403                     sty zpt+1   ;clear                
15c9 : ad0402                   lda abst+1
15cc : 49c3                     eor #$c3
15ce : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
15d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15d3 : 8c0402                   sty abst+1  ;clear                
15d6 : a504                     lda zpt+2
15d8 : 49c3                     eor #$c3
15da : c50b                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
15dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
15de : 8404                     sty zpt+2   ;clear                
15e0 : ad0502                   lda abst+2
15e3 : 49c3                     eor #$c3
15e5 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
15e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15ea : 8c0502                   sty abst+2  ;clear                
15ed : a505                     lda zpt+3
15ef : 49c3                     eor #$c3
15f1 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
15f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15f5 : 8405                     sty zpt+3   ;clear                
15f7 : ad0602                   lda abst+3
15fa : 49c3                     eor #$c3
15fc : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
15ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1601 : 8c0602                   sty abst+3  ;clear                
                                next_test
1604 : ad0002          >            lda test_case   ;previous test
1607 : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1609 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
160b : a915            >            lda #test_num   ;*** next tests' number
160d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1610 : a203                     ldx #3
1612 :                  tldax    
                                set_stat 0
                       >            load_flag 0
1612 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1614 : 48              >            pha         ;use stack to load status
1615 : 28              >            plp
                        
1616 : b509                     lda zp1,x
1618 : 08                       php         ;test stores do not alter flags
1619 : 49c3                     eor #$c3
161b : 28                       plp
161c : 9d0302                   sta abst,x
161f : 08                       php         ;flags after load/store sequence
1620 : 49c3                     eor #$c3
1622 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
1625 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1627 : 68                       pla         ;load status
                                eor_flag 0
1628 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
162a : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
162d : d0fe            >        bne *           ;failed not equal (non zero)
                        
162f : ca                       dex
1630 : 10e0                     bpl tldax                  
                        
1632 : a203                     ldx #3
1634 :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
1634 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1636 : 48              >            pha         ;use stack to load status
1637 : 28              >            plp
                        
1638 : b509                     lda zp1,x
163a : 08                       php         ;test stores do not alter flags
163b : 49c3                     eor #$c3
163d : 28                       plp
163e : 9d0302                   sta abst,x
1641 : 08                       php         ;flags after load/store sequence
1642 : 49c3                     eor #$c3
1644 : dd1702                   cmp abs1,x   ;test result
                                trap_ne
1647 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1649 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
164a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
164c : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
164f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1651 : ca                       dex
1652 : 10e0                     bpl tldax1                  
                        
1654 : a203                     ldx #3
1656 :                  tldax2   
                                set_stat 0
                       >            load_flag 0
1656 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1658 : 48              >            pha         ;use stack to load status
1659 : 28              >            plp
                        
165a : bd1702                   lda abs1,x
165d : 08                       php         ;test stores do not alter flags
165e : 49c3                     eor #$c3
1660 : 28                       plp
1661 : 9502                     sta zpt,x
1663 : 08                       php         ;flags after load/store sequence
1664 : 49c3                     eor #$c3
1666 : d509                     cmp zp1,x   ;test result
                                trap_ne
1668 : d0fe            >        bne *           ;failed not equal (non zero)
                        
166a : 68                       pla         ;load status
                                eor_flag 0
166b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
166d : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1670 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1672 : ca                       dex
1673 : 10e1                     bpl tldax2                  
                        
1675 : a203                     ldx #3
1677 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
1677 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1679 : 48              >            pha         ;use stack to load status
167a : 28              >            plp
                        
167b : bd1702                   lda abs1,x
167e : 08                       php         ;test stores do not alter flags
167f : 49c3                     eor #$c3
1681 : 28                       plp
1682 : 9502                     sta zpt,x
1684 : 08                       php         ;flags after load/store sequence
1685 : 49c3                     eor #$c3
1687 : d509                     cmp zp1,x   ;test result
                                trap_ne
1689 : d0fe            >        bne *           ;failed not equal (non zero)
                        
168b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
168c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
168e : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1691 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1693 : ca                       dex
1694 : 10e1                     bpl tldax3
                        
1696 : a203                     ldx #3      ;testing store result
1698 : a000                     ldy #0
169a : b502             tstax   lda zpt,x
169c : 49c3                     eor #$c3
169e : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
16a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a2 : 9402                     sty zpt,x   ;clear                
16a4 : bd0302                   lda abst,x
16a7 : 49c3                     eor #$c3
16a9 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
16ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ae : 8a                       txa
16af : 9d0302                   sta abst,x  ;clear                
16b2 : ca                       dex
16b3 : 10e5                     bpl tstax
                                next_test
16b5 : ad0002          >            lda test_case   ;previous test
16b8 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
16ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
16bc : a916            >            lda #test_num   ;*** next tests' number
16be : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
16c1 : a003                     ldy #3
16c3 :                  tlday    
                                set_stat 0
                       >            load_flag 0
16c3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
16c5 : 48              >            pha         ;use stack to load status
16c6 : 28              >            plp
                        
16c7 : b11a                     lda (ind1),y
16c9 : 08                       php         ;test stores do not alter flags
16ca : 49c3                     eor #$c3
16cc : 28                       plp
16cd : 990302                   sta abst,y
16d0 : 08                       php         ;flags after load/store sequence
16d1 : 49c3                     eor #$c3
16d3 : d91702                   cmp abs1,y  ;test result
                                trap_ne
16d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16d8 : 68                       pla         ;load status
                                eor_flag 0
16d9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
16db : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
16de : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e0 : 88                       dey
16e1 : 10e0                     bpl tlday                  
                        
16e3 : a003                     ldy #3
16e5 :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
16e5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16e7 : 48              >            pha         ;use stack to load status
16e8 : 28              >            plp
                        
16e9 : b11a                     lda (ind1),y
16eb : 08                       php         ;test stores do not alter flags
16ec : 49c3                     eor #$c3
16ee : 28                       plp
16ef : 990302                   sta abst,y
16f2 : 08                       php         ;flags after load/store sequence
16f3 : 49c3                     eor #$c3
16f5 : d91702                   cmp abs1,y  ;test result
                                trap_ne
16f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16fa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16fb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16fd : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1700 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1702 : 88                       dey
1703 : 10e0                     bpl tlday1                  
                        
1705 : a003                     ldy #3      ;testing store result
1707 : a200                     ldx #0
1709 : b90302           tstay   lda abst,y
170c : 49c3                     eor #$c3
170e : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1711 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1713 : 8a                       txa
1714 : 990302                   sta abst,y  ;clear                
1717 : 88                       dey
1718 : 10ef                     bpl tstay
                        
171a : a003                     ldy #3
171c :                  tlday2   
                                set_stat 0
                       >            load_flag 0
171c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
171e : 48              >            pha         ;use stack to load status
171f : 28              >            plp
                        
1720 : b91702                   lda abs1,y
1723 : 08                       php         ;test stores do not alter flags
1724 : 49c3                     eor #$c3
1726 : 28                       plp
1727 : 9126                     sta (indt),y
1729 : 08                       php         ;flags after load/store sequence
172a : 49c3                     eor #$c3
172c : d11a                     cmp (ind1),y    ;test result
                                trap_ne
172e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1730 : 68                       pla         ;load status
                                eor_flag 0
1731 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1733 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1736 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1738 : 88                       dey
1739 : 10e1                     bpl tlday2                  
                        
173b : a003                     ldy #3
173d :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
173d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
173f : 48              >            pha         ;use stack to load status
1740 : 28              >            plp
                        
1741 : b91702                   lda abs1,y
1744 : 08                       php         ;test stores do not alter flags
1745 : 49c3                     eor #$c3
1747 : 28                       plp
1748 : 9126                     sta (indt),y
174a : 08                       php         ;flags after load/store sequence
174b : 49c3                     eor #$c3
174d : d11a                     cmp (ind1),y   ;test result
                                trap_ne
174f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1751 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1752 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1754 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1757 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1759 : 88                       dey
175a : 10e1                     bpl tlday3
                                
175c : a003                     ldy #3      ;testing store result
175e : a200                     ldx #0
1760 : b90302           tstay1  lda abst,y
1763 : 49c3                     eor #$c3
1765 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1768 : d0fe            >        bne *           ;failed not equal (non zero)
                        
176a : 8a                       txa
176b : 990302                   sta abst,y  ;clear                
176e : 88                       dey
176f : 10ef                     bpl tstay1
                                
1771 : a206                     ldx #6
1773 : a003                     ldy #3
1775 :                  tldax4   
                                set_stat 0
                       >            load_flag 0
1775 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1777 : 48              >            pha         ;use stack to load status
1778 : 28              >            plp
                        
1779 : a11a                     lda (ind1,x)
177b : 08                       php         ;test stores do not alter flags
177c : 49c3                     eor #$c3
177e : 28                       plp
177f : 8126                     sta (indt,x)
1781 : 08                       php         ;flags after load/store sequence
1782 : 49c3                     eor #$c3
1784 : d91702                   cmp abs1,y  ;test result
                                trap_ne
1787 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1789 : 68                       pla         ;load status
                                eor_flag 0
178a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
178c : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
178f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1791 : ca                       dex
1792 : ca                       dex
1793 : 88                       dey
1794 : 10df                     bpl tldax4                  
                        
1796 : a206                     ldx #6
1798 : a003                     ldy #3
179a :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
179a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
179c : 48              >            pha         ;use stack to load status
179d : 28              >            plp
                        
179e : a11a                     lda (ind1,x)
17a0 : 08                       php         ;test stores do not alter flags
17a1 : 49c3                     eor #$c3
17a3 : 28                       plp
17a4 : 8126                     sta (indt,x)
17a6 : 08                       php         ;flags after load/store sequence
17a7 : 49c3                     eor #$c3
17a9 : d91702                   cmp abs1,y  ;test result
                                trap_ne
17ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
17ae : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17af : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
17b1 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
17b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b6 : ca                       dex
17b7 : ca                       dex
17b8 : 88                       dey
17b9 : 10df                     bpl tldax5
                        
17bb : a003                     ldy #3      ;testing store result
17bd : a200                     ldx #0
17bf : b90302           tstay2  lda abst,y
17c2 : 49c3                     eor #$c3
17c4 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
17c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17c9 : 8a                       txa
17ca : 990302                   sta abst,y  ;clear                
17cd : 88                       dey
17ce : 10ef                     bpl tstay2
                                next_test
17d0 : ad0002          >            lda test_case   ;previous test
17d3 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
17d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
17d7 : a917            >            lda #test_num   ;*** next tests' number
17d9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
17dc : a2fd                     ldx #3+$fa
17de : b50f             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
17e0 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
17e3 : ca                       dex
17e4 : e0fa                     cpx #$fa
17e6 : b0f6                     bcs tldax6                  
17e8 : a2fd                     ldx #3+$fa
17ea : bd1d01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
17ed : 9508                     sta zpt-$fa&$ff,x
17ef : ca                       dex
17f0 : e0fa                     cpx #$fa
17f2 : b0f6                     bcs tldax7
                                                  
17f4 : a203                     ldx #3      ;testing wraparound result
17f6 : a000                     ldy #0
17f8 : b502             tstax1  lda zpt,x
17fa : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
17fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
17fe : 9402                     sty zpt,x   ;clear                
1800 : bd0302                   lda abst,x
1803 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1806 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1808 : 8a                       txa
1809 : 9d0302                   sta abst,x  ;clear                
180c : ca                       dex
180d : 10e9                     bpl tstax1
                        
180f : a0fb                     ldy #3+$f8
1811 : a2fe                     ldx #6+$f8
1813 : a122             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
1815 : 990b01                   sta abst-$f8,y
1818 : ca                       dex
1819 : ca                       dex
181a : 88                       dey
181b : c0f8                     cpy #$f8
181d : b0f4                     bcs tlday4
181f : a003                     ldy #3      ;testing wraparound result
1821 : a200                     ldx #0
1823 : b90302           tstay4  lda abst,y
1826 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1829 : d0fe            >        bne *           ;failed not equal (non zero)
                        
182b : 8a                       txa
182c : 990302                   sta abst,y  ;clear                
182f : 88                       dey
1830 : 10f1                     bpl tstay4
                                
1832 : a0fb                     ldy #3+$f8
1834 : b91f01           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1837 : 912e                     sta (inwt),y
1839 : 88                       dey
183a : c0f8                     cpy #$f8
183c : b0f6                     bcs tlday5                  
183e : a003                     ldy #3      ;testing wraparound result
1840 : a200                     ldx #0
1842 : b90302           tstay5  lda abst,y
1845 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1848 : d0fe            >        bne *           ;failed not equal (non zero)
                        
184a : 8a                       txa
184b : 990302                   sta abst,y  ;clear                
184e : 88                       dey
184f : 10f1                     bpl tstay5
                        
1851 : a0fb                     ldy #3+$f8
1853 : a2fe                     ldx #6+$f8
1855 : b124             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
1857 : 812e                     sta (indt-$f8&$ff,x)
1859 : ca                       dex
185a : ca                       dex
185b : 88                       dey
185c : c0f8                     cpy #$f8
185e : b0f5                     bcs tlday6
1860 : a003                     ldy #3      ;testing wraparound result
1862 : a200                     ldx #0
1864 : b90302           tstay6  lda abst,y
1867 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
186a : d0fe            >        bne *           ;failed not equal (non zero)
                        
186c : 8a                       txa
186d : 990302                   sta abst,y  ;clear                
1870 : 88                       dey
1871 : 10f1                     bpl tstay6
                                next_test
1873 : ad0002          >            lda test_case   ;previous test
1876 : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1878 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
187a : a918            >            lda #test_num   ;*** next tests' number
187c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
187f : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1881 : 48              >            pha         ;use stack to load status
1882 : 28              >            plp
                        
1883 : a509                     lda zp1
1885 : 08                       php         ;test stores do not alter flags
1886 : 49c3                     eor #$c3
1888 : 28                       plp
1889 : 8d0302                   sta abst
188c : 08                       php         ;flags after load/store sequence
188d : 49c3                     eor #$c3
188f : c9c3                     cmp #$c3    ;test result
                                trap_ne
1891 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1893 : 68                       pla         ;load status
                                eor_flag 0
1894 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1896 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1899 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
189b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
189d : 48              >            pha         ;use stack to load status
189e : 28              >            plp
                        
189f : a50a                     lda zp1+1
18a1 : 08                       php         ;test stores do not alter flags
18a2 : 49c3                     eor #$c3
18a4 : 28                       plp
18a5 : 8d0402                   sta abst+1
18a8 : 08                       php         ;flags after load/store sequence
18a9 : 49c3                     eor #$c3
18ab : c982                     cmp #$82    ;test result
                                trap_ne
18ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
18af : 68                       pla         ;load status
                                eor_flag 0
18b0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18b2 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
18b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18b7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18b9 : 48              >            pha         ;use stack to load status
18ba : 28              >            plp
                        
18bb : a50b                     lda zp1+2
18bd : 08                       php         ;test stores do not alter flags
18be : 49c3                     eor #$c3
18c0 : 28                       plp
18c1 : 8d0502                   sta abst+2
18c4 : 08                       php         ;flags after load/store sequence
18c5 : 49c3                     eor #$c3
18c7 : c941                     cmp #$41    ;test result
                                trap_ne
18c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18cb : 68                       pla         ;load status
                                eor_flag 0
18cc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18ce : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
18d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18d3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18d5 : 48              >            pha         ;use stack to load status
18d6 : 28              >            plp
                        
18d7 : a50c                     lda zp1+3
18d9 : 08                       php         ;test stores do not alter flags
18da : 49c3                     eor #$c3
18dc : 28                       plp
18dd : 8d0602                   sta abst+3
18e0 : 08                       php         ;flags after load/store sequence
18e1 : 49c3                     eor #$c3
18e3 : c900                     cmp #0      ;test result
                                trap_ne
18e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18e7 : 68                       pla         ;load status
                                eor_flag 0
18e8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18ea : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
18ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18f1 : 48              >            pha         ;use stack to load status
18f2 : 28              >            plp
                        
18f3 : a509                     lda zp1  
18f5 : 08                       php         ;test stores do not alter flags
18f6 : 49c3                     eor #$c3
18f8 : 28                       plp
18f9 : 8d0302                   sta abst  
18fc : 08                       php         ;flags after load/store sequence
18fd : 49c3                     eor #$c3
18ff : c9c3                     cmp #$c3    ;test result
                                trap_ne
1901 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1903 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1904 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1906 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1909 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
190b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
190d : 48              >            pha         ;use stack to load status
190e : 28              >            plp
                        
190f : a50a                     lda zp1+1
1911 : 08                       php         ;test stores do not alter flags
1912 : 49c3                     eor #$c3
1914 : 28                       plp
1915 : 8d0402                   sta abst+1
1918 : 08                       php         ;flags after load/store sequence
1919 : 49c3                     eor #$c3
191b : c982                     cmp #$82    ;test result
                                trap_ne
191d : d0fe            >        bne *           ;failed not equal (non zero)
                        
191f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1920 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1922 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1925 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1927 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1929 : 48              >            pha         ;use stack to load status
192a : 28              >            plp
                        
192b : a50b                     lda zp1+2
192d : 08                       php         ;test stores do not alter flags
192e : 49c3                     eor #$c3
1930 : 28                       plp
1931 : 8d0502                   sta abst+2
1934 : 08                       php         ;flags after load/store sequence
1935 : 49c3                     eor #$c3
1937 : c941                     cmp #$41    ;test result
                                trap_ne
1939 : d0fe            >        bne *           ;failed not equal (non zero)
                        
193b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
193c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
193e : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1941 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1943 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1945 : 48              >            pha         ;use stack to load status
1946 : 28              >            plp
                        
1947 : a50c                     lda zp1+3
1949 : 08                       php         ;test stores do not alter flags
194a : 49c3                     eor #$c3
194c : 28                       plp
194d : 8d0602                   sta abst+3
1950 : 08                       php         ;flags after load/store sequence
1951 : 49c3                     eor #$c3
1953 : c900                     cmp #0      ;test result
                                trap_ne
1955 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1957 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1958 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
195a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
195d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
195f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1961 : 48              >            pha         ;use stack to load status
1962 : 28              >            plp
                        
1963 : ad1702                   lda abs1  
1966 : 08                       php         ;test stores do not alter flags
1967 : 49c3                     eor #$c3
1969 : 28                       plp
196a : 8502                     sta zpt  
196c : 08                       php         ;flags after load/store sequence
196d : 49c3                     eor #$c3
196f : c509                     cmp zp1     ;test result
                                trap_ne
1971 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1973 : 68                       pla         ;load status
                                eor_flag 0
1974 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1976 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1979 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
197b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
197d : 48              >            pha         ;use stack to load status
197e : 28              >            plp
                        
197f : ad1802                   lda abs1+1
1982 : 08                       php         ;test stores do not alter flags
1983 : 49c3                     eor #$c3
1985 : 28                       plp
1986 : 8503                     sta zpt+1
1988 : 08                       php         ;flags after load/store sequence
1989 : 49c3                     eor #$c3
198b : c50a                     cmp zp1+1   ;test result
                                trap_ne
198d : d0fe            >        bne *           ;failed not equal (non zero)
                        
198f : 68                       pla         ;load status
                                eor_flag 0
1990 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1992 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1995 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1997 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1999 : 48              >            pha         ;use stack to load status
199a : 28              >            plp
                        
199b : ad1902                   lda abs1+2
199e : 08                       php         ;test stores do not alter flags
199f : 49c3                     eor #$c3
19a1 : 28                       plp
19a2 : 8504                     sta zpt+2
19a4 : 08                       php         ;flags after load/store sequence
19a5 : 49c3                     eor #$c3
19a7 : c50b                     cmp zp1+2   ;test result
                                trap_ne
19a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ab : 68                       pla         ;load status
                                eor_flag 0
19ac : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19ae : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
19b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19b3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19b5 : 48              >            pha         ;use stack to load status
19b6 : 28              >            plp
                        
19b7 : ad1a02                   lda abs1+3
19ba : 08                       php         ;test stores do not alter flags
19bb : 49c3                     eor #$c3
19bd : 28                       plp
19be : 8505                     sta zpt+3
19c0 : 08                       php         ;flags after load/store sequence
19c1 : 49c3                     eor #$c3
19c3 : c50c                     cmp zp1+3   ;test result
                                trap_ne
19c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19c7 : 68                       pla         ;load status
                                eor_flag 0
19c8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19ca : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
19cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19d1 : 48              >            pha         ;use stack to load status
19d2 : 28              >            plp
                        
19d3 : ad1702                   lda abs1  
19d6 : 08                       php         ;test stores do not alter flags
19d7 : 49c3                     eor #$c3
19d9 : 28                       plp
19da : 8502                     sta zpt  
19dc : 08                       php         ;flags after load/store sequence
19dd : 49c3                     eor #$c3
19df : c509                     cmp zp1     ;test result
                                trap_ne
19e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19e3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19e4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19e6 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
19e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19eb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19ed : 48              >            pha         ;use stack to load status
19ee : 28              >            plp
                        
19ef : ad1802                   lda abs1+1
19f2 : 08                       php         ;test stores do not alter flags
19f3 : 49c3                     eor #$c3
19f5 : 28                       plp
19f6 : 8503                     sta zpt+1
19f8 : 08                       php         ;flags after load/store sequence
19f9 : 49c3                     eor #$c3
19fb : c50a                     cmp zp1+1   ;test result
                                trap_ne
19fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ff : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a00 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a02 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a05 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a07 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a09 : 48              >            pha         ;use stack to load status
1a0a : 28              >            plp
                        
1a0b : ad1902                   lda abs1+2
1a0e : 08                       php         ;test stores do not alter flags
1a0f : 49c3                     eor #$c3
1a11 : 28                       plp
1a12 : 8504                     sta zpt+2
1a14 : 08                       php         ;flags after load/store sequence
1a15 : 49c3                     eor #$c3
1a17 : c50b                     cmp zp1+2   ;test result
                                trap_ne
1a19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a1b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a1c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a1e : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a23 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a25 : 48              >            pha         ;use stack to load status
1a26 : 28              >            plp
                        
1a27 : ad1a02                   lda abs1+3
1a2a : 08                       php         ;test stores do not alter flags
1a2b : 49c3                     eor #$c3
1a2d : 28                       plp
1a2e : 8505                     sta zpt+3
1a30 : 08                       php         ;flags after load/store sequence
1a31 : 49c3                     eor #$c3
1a33 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1a35 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a37 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a38 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a3a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a3d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a3f : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1a41 : 48              >            pha         ;use stack to load status
1a42 : 28              >            plp
                        
1a43 : a9c3                     lda #$c3
1a45 : 08                       php
1a46 : cd1702                   cmp abs1    ;test result
                                trap_ne
1a49 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a4b : 68                       pla         ;load status
                                eor_flag 0
1a4c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a4e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a51 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a53 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a55 : 48              >            pha         ;use stack to load status
1a56 : 28              >            plp
                        
1a57 : a982                     lda #$82
1a59 : 08                       php
1a5a : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1a5d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a5f : 68                       pla         ;load status
                                eor_flag 0
1a60 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a62 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a65 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a69 : 48              >            pha         ;use stack to load status
1a6a : 28              >            plp
                        
1a6b : a941                     lda #$41
1a6d : 08                       php
1a6e : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1a71 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a73 : 68                       pla         ;load status
                                eor_flag 0
1a74 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a76 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a79 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a7d : 48              >            pha         ;use stack to load status
1a7e : 28              >            plp
                        
1a7f : a900                     lda #0
1a81 : 08                       php
1a82 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1a85 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a87 : 68                       pla         ;load status
                                eor_flag 0
1a88 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a8a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a8d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1a8f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a91 : 48              >            pha         ;use stack to load status
1a92 : 28              >            plp
                        
1a93 : a9c3                     lda #$c3  
1a95 : 08                       php
1a96 : cd1702                   cmp abs1    ;test result
                                trap_ne
1a99 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a9b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a9c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a9e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1aa1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1aa3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aa5 : 48              >            pha         ;use stack to load status
1aa6 : 28              >            plp
                        
1aa7 : a982                     lda #$82
1aa9 : 08                       php
1aaa : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1aad : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aaf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ab0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ab2 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1ab5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ab7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ab9 : 48              >            pha         ;use stack to load status
1aba : 28              >            plp
                        
1abb : a941                     lda #$41
1abd : 08                       php
1abe : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1ac1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ac3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ac4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ac6 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1ac9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1acb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1acd : 48              >            pha         ;use stack to load status
1ace : 28              >            plp
                        
1acf : a900                     lda #0
1ad1 : 08                       php
1ad2 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1ad5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ad7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ad8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ada : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1add : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1adf : a200                     ldx #0
1ae1 : a502                     lda zpt  
1ae3 : 49c3                     eor #$c3
1ae5 : c509                     cmp zp1  
                                trap_ne     ;store to zp data
1ae7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ae9 : 8602                     stx zpt     ;clear                
1aeb : ad0302                   lda abst  
1aee : 49c3                     eor #$c3
1af0 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1af3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1af5 : 8e0302                   stx abst    ;clear                
1af8 : a503                     lda zpt+1
1afa : 49c3                     eor #$c3
1afc : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
1afe : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b00 : 8603                     stx zpt+1   ;clear                
1b02 : ad0402                   lda abst+1
1b05 : 49c3                     eor #$c3
1b07 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1b0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b0c : 8e0402                   stx abst+1  ;clear                
1b0f : a504                     lda zpt+2
1b11 : 49c3                     eor #$c3
1b13 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
1b15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b17 : 8604                     stx zpt+2   ;clear                
1b19 : ad0502                   lda abst+2
1b1c : 49c3                     eor #$c3
1b1e : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1b21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b23 : 8e0502                   stx abst+2  ;clear                
1b26 : a505                     lda zpt+3
1b28 : 49c3                     eor #$c3
1b2a : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
1b2c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b2e : 8605                     stx zpt+3   ;clear                
1b30 : ad0602                   lda abst+3
1b33 : 49c3                     eor #$c3
1b35 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b38 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b3a : 8e0602                   stx abst+3  ;clear                
                                next_test
1b3d : ad0002          >            lda test_case   ;previous test
1b40 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b44 : a919            >            lda #test_num   ;*** next tests' number
1b46 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1b49 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b4b : 48              >            pha         ;use stack to load status
1b4c : a9ff            >            lda #$ff     ;precharge accu
1b4e : 28              >            plp
                        
1b4f : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b51 : 08              >            php         ;save flags
1b52 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b56 : 68              >            pla         ;load status
1b57 : 48              >            pha
                       >            cmp_flag fz 
1b58 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b5c : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b5d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b5f : 48              >            pha         ;use stack to load status
1b60 : a901            >            lda #1     ;precharge accu
1b62 : 28              >            plp
                        
1b63 : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b65 : 08              >            php         ;save flags
1b66 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b6a : 68              >            pla         ;load status
1b6b : 48              >            pha
                       >            cmp_flag fv
1b6c : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b70 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b73 : 48              >            pha         ;use stack to load status
1b74 : a901            >            lda #1     ;precharge accu
1b76 : 28              >            plp
                        
1b77 : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b79 : 08              >            php         ;save flags
1b7a : c901            >            cmp #1     ;test result
                       >            trap_ne
1b7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b7e : 68              >            pla         ;load status
1b7f : 48              >            pha
                       >            cmp_flag fnz
1b80 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b84 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b85 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b87 : 48              >            pha         ;use stack to load status
1b88 : a901            >            lda #1     ;precharge accu
1b8a : 28              >            plp
                        
1b8b : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b8d : 08              >            php         ;save flags
1b8e : c901            >            cmp #1     ;test result
                       >            trap_ne
1b90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b92 : 68              >            pla         ;load status
1b93 : 48              >            pha
                       >            cmp_flag fnv
1b94 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b98 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b99 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b9b : 48              >            pha         ;use stack to load status
1b9c : a9ff            >            lda #$ff     ;precharge accu
1b9e : 28              >            plp
                        
1b9f : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1ba1 : 08              >            php         ;save flags
1ba2 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1ba4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba6 : 68              >            pla         ;load status
1ba7 : 48              >            pha
                       >            cmp_flag ~fnv 
1ba8 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1baa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bac : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bad : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1baf : 48              >            pha         ;use stack to load status
1bb0 : a901            >            lda #1     ;precharge accu
1bb2 : 28              >            plp
                        
1bb3 : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1bb5 : 08              >            php         ;save flags
1bb6 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bb8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bba : 68              >            pla         ;load status
1bbb : 48              >            pha
                       >            cmp_flag ~fnz
1bbc : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc0 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bc1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bc3 : 48              >            pha         ;use stack to load status
1bc4 : a901            >            lda #1     ;precharge accu
1bc6 : 28              >            plp
                        
1bc7 : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1bc9 : 08              >            php         ;save flags
1bca : c901            >            cmp #1     ;test result
                       >            trap_ne
1bcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bce : 68              >            pla         ;load status
1bcf : 48              >            pha
                       >            cmp_flag ~fv
1bd0 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd4 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bd5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bd7 : 48              >            pha         ;use stack to load status
1bd8 : a901            >            lda #1     ;precharge accu
1bda : 28              >            plp
                        
1bdb : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1bdd : 08              >            php         ;save flags
1bde : c901            >            cmp #1     ;test result
                       >            trap_ne
1be0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be2 : 68              >            pla         ;load status
1be3 : 48              >            pha
                       >            cmp_flag ~fz
1be4 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1be6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be8 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1be9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1beb : 48              >            pha         ;use stack to load status
1bec : a9ff            >            lda #$ff     ;precharge accu
1bee : 28              >            plp
                        
1bef : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1bf2 : 08              >            php         ;save flags
1bf3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bf7 : 68              >            pla         ;load status
1bf8 : 48              >            pha
                       >            cmp_flag fz 
1bf9 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bfb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bfd : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bfe : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c00 : 48              >            pha         ;use stack to load status
1c01 : a901            >            lda #1     ;precharge accu
1c03 : 28              >            plp
                        
1c04 : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1c07 : 08              >            php         ;save flags
1c08 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c0c : 68              >            pla         ;load status
1c0d : 48              >            pha
                       >            cmp_flag fv
1c0e : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c12 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c13 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c15 : 48              >            pha         ;use stack to load status
1c16 : a901            >            lda #1     ;precharge accu
1c18 : 28              >            plp
                        
1c19 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1c1c : 08              >            php         ;save flags
1c1d : c901            >            cmp #1     ;test result
                       >            trap_ne
1c1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c21 : 68              >            pla         ;load status
1c22 : 48              >            pha
                       >            cmp_flag fnz
1c23 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c27 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c28 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c2a : 48              >            pha         ;use stack to load status
1c2b : a901            >            lda #1     ;precharge accu
1c2d : 28              >            plp
                        
1c2e : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c31 : 08              >            php         ;save flags
1c32 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c36 : 68              >            pla         ;load status
1c37 : 48              >            pha
                       >            cmp_flag fnv
1c38 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3c : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c3d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c3f : 48              >            pha         ;use stack to load status
1c40 : a9ff            >            lda #$ff     ;precharge accu
1c42 : 28              >            plp
                        
1c43 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c46 : 08              >            php         ;save flags
1c47 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c4b : 68              >            pla         ;load status
1c4c : 48              >            pha
                       >            cmp_flag ~fnv 
1c4d : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c51 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c54 : 48              >            pha         ;use stack to load status
1c55 : a901            >            lda #1     ;precharge accu
1c57 : 28              >            plp
                        
1c58 : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c5b : 08              >            php         ;save flags
1c5c : c901            >            cmp #1     ;test result
                       >            trap_ne
1c5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c60 : 68              >            pla         ;load status
1c61 : 48              >            pha
                       >            cmp_flag ~fnz
1c62 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c66 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c67 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c69 : 48              >            pha         ;use stack to load status
1c6a : a901            >            lda #1     ;precharge accu
1c6c : 28              >            plp
                        
1c6d : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c70 : 08              >            php         ;save flags
1c71 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c75 : 68              >            pla         ;load status
1c76 : 48              >            pha
                       >            cmp_flag ~fv
1c77 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c7b : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c7c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c7e : 48              >            pha         ;use stack to load status
1c7f : a901            >            lda #1     ;precharge accu
1c81 : 28              >            plp
                        
1c82 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c85 : 08              >            php         ;save flags
1c86 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c8a : 68              >            pla         ;load status
1c8b : 48              >            pha
                       >            cmp_flag ~fz
1c8c : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c90 : 28              >            plp         ;restore status
                        
                                next_test
1c91 : ad0002          >            lda test_case   ;previous test
1c94 : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1c98 : a91a            >            lda #test_num   ;*** next tests' number
1c9a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1c9d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c9f : 48              >            pha         ;use stack to load status
1ca0 : a280            >            ldx #$80     ;precharge index x
1ca2 : 28              >            plp
                        
1ca3 : e40d                     cpx zp7f
                                tst_stat fc
1ca5 : 08              >            php         ;save status
1ca6 : 68              >            pla         ;use stack to retrieve status
1ca7 : 48              >            pha
                       >            cmp_flag fc
1ca8 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1caa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cac : 28              >            plp         ;restore status
                        
1cad : ca                       dex
1cae : e40d                     cpx zp7f
                                tst_stat fzc
1cb0 : 08              >            php         ;save status
1cb1 : 68              >            pla         ;use stack to retrieve status
1cb2 : 48              >            pha
                       >            cmp_flag fzc
1cb3 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cb7 : 28              >            plp         ;restore status
                        
1cb8 : ca                       dex
1cb9 : e40d                     cpx zp7f
                                tst_x $7e,fn
1cbb : 08              >            php         ;save flags
1cbc : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc0 : 68              >            pla         ;load status
1cc1 : 48              >            pha
                       >            cmp_flag fn
1cc2 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc6 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1cc7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cc9 : 48              >            pha         ;use stack to load status
1cca : a280            >            ldx #$80     ;precharge index x
1ccc : 28              >            plp
                        
1ccd : e40d                     cpx zp7f
                                tst_stat ~fnz
1ccf : 08              >            php         ;save status
1cd0 : 68              >            pla         ;use stack to retrieve status
1cd1 : 48              >            pha
                       >            cmp_flag ~fnz
1cd2 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd6 : 28              >            plp         ;restore status
                        
1cd7 : ca                       dex
1cd8 : e40d                     cpx zp7f
                                tst_stat ~fn
1cda : 08              >            php         ;save status
1cdb : 68              >            pla         ;use stack to retrieve status
1cdc : 48              >            pha
                       >            cmp_flag ~fn
1cdd : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce1 : 28              >            plp         ;restore status
                        
1ce2 : ca                       dex
1ce3 : e40d                     cpx zp7f
                                tst_x $7e,~fzc
1ce5 : 08              >            php         ;save flags
1ce6 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1ce8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cea : 68              >            pla         ;load status
1ceb : 48              >            pha
                       >            cmp_flag ~fzc
1cec : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf0 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1cf1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cf3 : 48              >            pha         ;use stack to load status
1cf4 : a280            >            ldx #$80     ;precharge index x
1cf6 : 28              >            plp
                        
1cf7 : ec1b02                   cpx abs7f
                                tst_stat fc
1cfa : 08              >            php         ;save status
1cfb : 68              >            pla         ;use stack to retrieve status
1cfc : 48              >            pha
                       >            cmp_flag fc
1cfd : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d01 : 28              >            plp         ;restore status
                        
1d02 : ca                       dex
1d03 : ec1b02                   cpx abs7f
                                tst_stat fzc
1d06 : 08              >            php         ;save status
1d07 : 68              >            pla         ;use stack to retrieve status
1d08 : 48              >            pha
                       >            cmp_flag fzc
1d09 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d0d : 28              >            plp         ;restore status
                        
1d0e : ca                       dex
1d0f : ec1b02                   cpx abs7f
                                tst_x $7e,fn
1d12 : 08              >            php         ;save flags
1d13 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d17 : 68              >            pla         ;load status
1d18 : 48              >            pha
                       >            cmp_flag fn
1d19 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1d : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d1e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d20 : 48              >            pha         ;use stack to load status
1d21 : a280            >            ldx #$80     ;precharge index x
1d23 : 28              >            plp
                        
1d24 : ec1b02                   cpx abs7f
                                tst_stat ~fnz
1d27 : 08              >            php         ;save status
1d28 : 68              >            pla         ;use stack to retrieve status
1d29 : 48              >            pha
                       >            cmp_flag ~fnz
1d2a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d2e : 28              >            plp         ;restore status
                        
1d2f : ca                       dex
1d30 : ec1b02                   cpx abs7f
                                tst_stat ~fn
1d33 : 08              >            php         ;save status
1d34 : 68              >            pla         ;use stack to retrieve status
1d35 : 48              >            pha
                       >            cmp_flag ~fn
1d36 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d3a : 28              >            plp         ;restore status
                        
1d3b : ca                       dex
1d3c : ec1b02                   cpx abs7f
                                tst_x $7e,~fzc
1d3f : 08              >            php         ;save flags
1d40 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d44 : 68              >            pla         ;load status
1d45 : 48              >            pha
                       >            cmp_flag ~fzc
1d46 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d4a : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d4b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d4d : 48              >            pha         ;use stack to load status
1d4e : a280            >            ldx #$80     ;precharge index x
1d50 : 28              >            plp
                        
1d51 : e07f                     cpx #$7f
                                tst_stat fc
1d53 : 08              >            php         ;save status
1d54 : 68              >            pla         ;use stack to retrieve status
1d55 : 48              >            pha
                       >            cmp_flag fc
1d56 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5a : 28              >            plp         ;restore status
                        
1d5b : ca                       dex
1d5c : e07f                     cpx #$7f
                                tst_stat fzc
1d5e : 08              >            php         ;save status
1d5f : 68              >            pla         ;use stack to retrieve status
1d60 : 48              >            pha
                       >            cmp_flag fzc
1d61 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d65 : 28              >            plp         ;restore status
                        
1d66 : ca                       dex
1d67 : e07f                     cpx #$7f
                                tst_x $7e,fn
1d69 : 08              >            php         ;save flags
1d6a : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d6e : 68              >            pla         ;load status
1d6f : 48              >            pha
                       >            cmp_flag fn
1d70 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d74 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d75 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d77 : 48              >            pha         ;use stack to load status
1d78 : a280            >            ldx #$80     ;precharge index x
1d7a : 28              >            plp
                        
1d7b : e07f                     cpx #$7f
                                tst_stat ~fnz
1d7d : 08              >            php         ;save status
1d7e : 68              >            pla         ;use stack to retrieve status
1d7f : 48              >            pha
                       >            cmp_flag ~fnz
1d80 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d84 : 28              >            plp         ;restore status
                        
1d85 : ca                       dex
1d86 : e07f                     cpx #$7f
                                tst_stat ~fn
1d88 : 08              >            php         ;save status
1d89 : 68              >            pla         ;use stack to retrieve status
1d8a : 48              >            pha
                       >            cmp_flag ~fn
1d8b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d8f : 28              >            plp         ;restore status
                        
1d90 : ca                       dex
1d91 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1d93 : 08              >            php         ;save flags
1d94 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d98 : 68              >            pla         ;load status
1d99 : 48              >            pha
                       >            cmp_flag ~fzc
1d9a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d9e : 28              >            plp         ;restore status
                        
                                next_test
1d9f : ad0002          >            lda test_case   ;previous test
1da2 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1da4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1da6 : a91b            >            lda #test_num   ;*** next tests' number
1da8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1dab : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dad : 48              >            pha         ;use stack to load status
1dae : a080            >            ldy #$80     ;precharge index y
1db0 : 28              >            plp
                        
1db1 : c40d                     cpy zp7f
                                tst_stat fc
1db3 : 08              >            php         ;save status
1db4 : 68              >            pla         ;use stack to retrieve status
1db5 : 48              >            pha
                       >            cmp_flag fc
1db6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1db8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dba : 28              >            plp         ;restore status
                        
1dbb : 88                       dey
1dbc : c40d                     cpy zp7f
                                tst_stat fzc
1dbe : 08              >            php         ;save status
1dbf : 68              >            pla         ;use stack to retrieve status
1dc0 : 48              >            pha
                       >            cmp_flag fzc
1dc1 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dc3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc5 : 28              >            plp         ;restore status
                        
1dc6 : 88                       dey
1dc7 : c40d                     cpy zp7f
                                tst_y $7e,fn
1dc9 : 08              >            php         ;save flags
1dca : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dce : 68              >            pla         ;load status
1dcf : 48              >            pha
                       >            cmp_flag fn
1dd0 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd4 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1dd5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1dd7 : 48              >            pha         ;use stack to load status
1dd8 : a080            >            ldy #$80     ;precharge index y
1dda : 28              >            plp
                        
1ddb : c40d                     cpy zp7f
                                tst_stat ~fnz
1ddd : 08              >            php         ;save status
1dde : 68              >            pla         ;use stack to retrieve status
1ddf : 48              >            pha
                       >            cmp_flag ~fnz
1de0 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1de2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de4 : 28              >            plp         ;restore status
                        
1de5 : 88                       dey
1de6 : c40d                     cpy zp7f
                                tst_stat ~fn
1de8 : 08              >            php         ;save status
1de9 : 68              >            pla         ;use stack to retrieve status
1dea : 48              >            pha
                       >            cmp_flag ~fn
1deb : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ded : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1def : 28              >            plp         ;restore status
                        
1df0 : 88                       dey
1df1 : c40d                     cpy zp7f
                                tst_y $7e,~fzc
1df3 : 08              >            php         ;save flags
1df4 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1df6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1df8 : 68              >            pla         ;load status
1df9 : 48              >            pha
                       >            cmp_flag ~fzc
1dfa : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dfc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dfe : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1dff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e01 : 48              >            pha         ;use stack to load status
1e02 : a080            >            ldy #$80     ;precharge index y
1e04 : 28              >            plp
                        
1e05 : cc1b02                   cpy abs7f
                                tst_stat fc
1e08 : 08              >            php         ;save status
1e09 : 68              >            pla         ;use stack to retrieve status
1e0a : 48              >            pha
                       >            cmp_flag fc
1e0b : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e0f : 28              >            plp         ;restore status
                        
1e10 : 88                       dey
1e11 : cc1b02                   cpy abs7f
                                tst_stat fzc
1e14 : 08              >            php         ;save status
1e15 : 68              >            pla         ;use stack to retrieve status
1e16 : 48              >            pha
                       >            cmp_flag fzc
1e17 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e1b : 28              >            plp         ;restore status
                        
1e1c : 88                       dey
1e1d : cc1b02                   cpy abs7f
                                tst_y $7e,fn
1e20 : 08              >            php         ;save flags
1e21 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e25 : 68              >            pla         ;load status
1e26 : 48              >            pha
                       >            cmp_flag fn
1e27 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2b : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e2c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e2e : 48              >            pha         ;use stack to load status
1e2f : a080            >            ldy #$80     ;precharge index y
1e31 : 28              >            plp
                        
1e32 : cc1b02                   cpy abs7f
                                tst_stat ~fnz
1e35 : 08              >            php         ;save status
1e36 : 68              >            pla         ;use stack to retrieve status
1e37 : 48              >            pha
                       >            cmp_flag ~fnz
1e38 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e3c : 28              >            plp         ;restore status
                        
1e3d : 88                       dey
1e3e : cc1b02                   cpy abs7f
                                tst_stat ~fn
1e41 : 08              >            php         ;save status
1e42 : 68              >            pla         ;use stack to retrieve status
1e43 : 48              >            pha
                       >            cmp_flag ~fn
1e44 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e48 : 28              >            plp         ;restore status
                        
1e49 : 88                       dey
1e4a : cc1b02                   cpy abs7f
                                tst_y $7e,~fzc
1e4d : 08              >            php         ;save flags
1e4e : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e52 : 68              >            pla         ;load status
1e53 : 48              >            pha
                       >            cmp_flag ~fzc
1e54 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e58 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e59 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e5b : 48              >            pha         ;use stack to load status
1e5c : a080            >            ldy #$80     ;precharge index y
1e5e : 28              >            plp
                        
1e5f : c07f                     cpy #$7f
                                tst_stat fc
1e61 : 08              >            php         ;save status
1e62 : 68              >            pla         ;use stack to retrieve status
1e63 : 48              >            pha
                       >            cmp_flag fc
1e64 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e68 : 28              >            plp         ;restore status
                        
1e69 : 88                       dey
1e6a : c07f                     cpy #$7f
                                tst_stat fzc
1e6c : 08              >            php         ;save status
1e6d : 68              >            pla         ;use stack to retrieve status
1e6e : 48              >            pha
                       >            cmp_flag fzc
1e6f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e73 : 28              >            plp         ;restore status
                        
1e74 : 88                       dey
1e75 : c07f                     cpy #$7f
                                tst_y $7e,fn
1e77 : 08              >            php         ;save flags
1e78 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e7c : 68              >            pla         ;load status
1e7d : 48              >            pha
                       >            cmp_flag fn
1e7e : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e82 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e83 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e85 : 48              >            pha         ;use stack to load status
1e86 : a080            >            ldy #$80     ;precharge index y
1e88 : 28              >            plp
                        
1e89 : c07f                     cpy #$7f
                                tst_stat ~fnz
1e8b : 08              >            php         ;save status
1e8c : 68              >            pla         ;use stack to retrieve status
1e8d : 48              >            pha
                       >            cmp_flag ~fnz
1e8e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e92 : 28              >            plp         ;restore status
                        
1e93 : 88                       dey
1e94 : c07f                     cpy #$7f
                                tst_stat ~fn
1e96 : 08              >            php         ;save status
1e97 : 68              >            pla         ;use stack to retrieve status
1e98 : 48              >            pha
                       >            cmp_flag ~fn
1e99 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e9d : 28              >            plp         ;restore status
                        
1e9e : 88                       dey
1e9f : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1ea1 : 08              >            php         ;save flags
1ea2 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1ea4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea6 : 68              >            pla         ;load status
1ea7 : 48              >            pha
                       >            cmp_flag ~fzc
1ea8 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eaa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eac : 28              >            plp         ;restore status
                        
                                next_test
1ead : ad0002          >            lda test_case   ;previous test
1eb0 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1eb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1eb4 : a91c            >            lda #test_num   ;*** next tests' number
1eb6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1eb9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ebb : 48              >            pha         ;use stack to load status
1ebc : a980            >            lda #$80     ;precharge accu
1ebe : 28              >            plp
                        
1ebf : c50d                     cmp zp7f
                                tst_a $80,fc
1ec1 : 08              >            php         ;save flags
1ec2 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ec4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec6 : 68              >            pla         ;load status
1ec7 : 48              >            pha
                       >            cmp_flag fc
1ec8 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ecc : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ecd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ecf : 48              >            pha         ;use stack to load status
1ed0 : a97f            >            lda #$7f     ;precharge accu
1ed2 : 28              >            plp
                        
1ed3 : c50d                     cmp zp7f
                                tst_a $7f,fzc
1ed5 : 08              >            php         ;save flags
1ed6 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ed8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eda : 68              >            pla         ;load status
1edb : 48              >            pha
                       >            cmp_flag fzc
1edc : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ede : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ee0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1ee1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ee3 : 48              >            pha         ;use stack to load status
1ee4 : a97e            >            lda #$7e     ;precharge accu
1ee6 : 28              >            plp
                        
1ee7 : c50d                     cmp zp7f
                                tst_a $7e,fn
1ee9 : 08              >            php         ;save flags
1eea : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1eec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eee : 68              >            pla         ;load status
1eef : 48              >            pha
                       >            cmp_flag fn
1ef0 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef4 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ef5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ef7 : 48              >            pha         ;use stack to load status
1ef8 : a980            >            lda #$80     ;precharge accu
1efa : 28              >            plp
                        
1efb : c50d                     cmp zp7f
                                tst_a $80,~fnz
1efd : 08              >            php         ;save flags
1efe : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f02 : 68              >            pla         ;load status
1f03 : 48              >            pha
                       >            cmp_flag ~fnz
1f04 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f08 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f09 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f0b : 48              >            pha         ;use stack to load status
1f0c : a97f            >            lda #$7f     ;precharge accu
1f0e : 28              >            plp
                        
1f0f : c50d                     cmp zp7f
                                tst_a $7f,~fn
1f11 : 08              >            php         ;save flags
1f12 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f16 : 68              >            pla         ;load status
1f17 : 48              >            pha
                       >            cmp_flag ~fn
1f18 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f1d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f1f : 48              >            pha         ;use stack to load status
1f20 : a97e            >            lda #$7e     ;precharge accu
1f22 : 28              >            plp
                        
1f23 : c50d                     cmp zp7f
                                tst_a $7e,~fzc
1f25 : 08              >            php         ;save flags
1f26 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f2a : 68              >            pla         ;load status
1f2b : 48              >            pha
                       >            cmp_flag ~fzc
1f2c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f30 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f31 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f33 : 48              >            pha         ;use stack to load status
1f34 : a980            >            lda #$80     ;precharge accu
1f36 : 28              >            plp
                        
1f37 : cd1b02                   cmp abs7f
                                tst_a $80,fc
1f3a : 08              >            php         ;save flags
1f3b : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f3f : 68              >            pla         ;load status
1f40 : 48              >            pha
                       >            cmp_flag fc
1f41 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f45 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f48 : 48              >            pha         ;use stack to load status
1f49 : a97f            >            lda #$7f     ;precharge accu
1f4b : 28              >            plp
                        
1f4c : cd1b02                   cmp abs7f
                                tst_a $7f,fzc
1f4f : 08              >            php         ;save flags
1f50 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f54 : 68              >            pla         ;load status
1f55 : 48              >            pha
                       >            cmp_flag fzc
1f56 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5a : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f5b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f5d : 48              >            pha         ;use stack to load status
1f5e : a97e            >            lda #$7e     ;precharge accu
1f60 : 28              >            plp
                        
1f61 : cd1b02                   cmp abs7f
                                tst_a $7e,fn
1f64 : 08              >            php         ;save flags
1f65 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f69 : 68              >            pla         ;load status
1f6a : 48              >            pha
                       >            cmp_flag fn
1f6b : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6f : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f70 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f72 : 48              >            pha         ;use stack to load status
1f73 : a980            >            lda #$80     ;precharge accu
1f75 : 28              >            plp
                        
1f76 : cd1b02                   cmp abs7f
                                tst_a $80,~fnz
1f79 : 08              >            php         ;save flags
1f7a : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f7e : 68              >            pla         ;load status
1f7f : 48              >            pha
                       >            cmp_flag ~fnz
1f80 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f84 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f85 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f87 : 48              >            pha         ;use stack to load status
1f88 : a97f            >            lda #$7f     ;precharge accu
1f8a : 28              >            plp
                        
1f8b : cd1b02                   cmp abs7f
                                tst_a $7f,~fn
1f8e : 08              >            php         ;save flags
1f8f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f93 : 68              >            pla         ;load status
1f94 : 48              >            pha
                       >            cmp_flag ~fn
1f95 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f97 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f99 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f9a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f9c : 48              >            pha         ;use stack to load status
1f9d : a97e            >            lda #$7e     ;precharge accu
1f9f : 28              >            plp
                        
1fa0 : cd1b02                   cmp abs7f
                                tst_a $7e,~fzc
1fa3 : 08              >            php         ;save flags
1fa4 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fa6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fa8 : 68              >            pla         ;load status
1fa9 : 48              >            pha
                       >            cmp_flag ~fzc
1faa : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fae : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1faf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fb1 : 48              >            pha         ;use stack to load status
1fb2 : a980            >            lda #$80     ;precharge accu
1fb4 : 28              >            plp
                        
1fb5 : c97f                     cmp #$7f
                                tst_a $80,fc
1fb7 : 08              >            php         ;save flags
1fb8 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbc : 68              >            pla         ;load status
1fbd : 48              >            pha
                       >            cmp_flag fc
1fbe : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc2 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1fc3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fc5 : 48              >            pha         ;use stack to load status
1fc6 : a97f            >            lda #$7f     ;precharge accu
1fc8 : 28              >            plp
                        
1fc9 : c97f                     cmp #$7f
                                tst_a $7f,fzc
1fcb : 08              >            php         ;save flags
1fcc : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd0 : 68              >            pla         ;load status
1fd1 : 48              >            pha
                       >            cmp_flag fzc
1fd2 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd6 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fd7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fd9 : 48              >            pha         ;use stack to load status
1fda : a97e            >            lda #$7e     ;precharge accu
1fdc : 28              >            plp
                        
1fdd : c97f                     cmp #$7f
                                tst_a $7e,fn
1fdf : 08              >            php         ;save flags
1fe0 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fe2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe4 : 68              >            pla         ;load status
1fe5 : 48              >            pha
                       >            cmp_flag fn
1fe6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fe8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fea : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1feb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fed : 48              >            pha         ;use stack to load status
1fee : a980            >            lda #$80     ;precharge accu
1ff0 : 28              >            plp
                        
1ff1 : c97f                     cmp #$7f
                                tst_a $80,~fnz
1ff3 : 08              >            php         ;save flags
1ff4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ff6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ff8 : 68              >            pla         ;load status
1ff9 : 48              >            pha
                       >            cmp_flag ~fnz
1ffa : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ffc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffe : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2001 : 48              >            pha         ;use stack to load status
2002 : a97f            >            lda #$7f     ;precharge accu
2004 : 28              >            plp
                        
2005 : c97f                     cmp #$7f
                                tst_a $7f,~fn
2007 : 08              >            php         ;save flags
2008 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
200a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
200c : 68              >            pla         ;load status
200d : 48              >            pha
                       >            cmp_flag ~fn
200e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2010 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2012 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2013 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2015 : 48              >            pha         ;use stack to load status
2016 : a97e            >            lda #$7e     ;precharge accu
2018 : 28              >            plp
                        
2019 : c97f                     cmp #$7f
                                tst_a $7e,~fzc
201b : 08              >            php         ;save flags
201c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
201e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2020 : 68              >            pla         ;load status
2021 : 48              >            pha
                       >            cmp_flag ~fzc
2022 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2024 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2026 : 28              >            plp         ;restore status
                        
                        
2027 : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
2029 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
202b : 48              >            pha         ;use stack to load status
202c : a980            >            lda #$80     ;precharge accu
202e : 28              >            plp
                        
202f : d509                     cmp zp1,x
                                tst_a $80,fc
2031 : 08              >            php         ;save flags
2032 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2034 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2036 : 68              >            pla         ;load status
2037 : 48              >            pha
                       >            cmp_flag fc
2038 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
203a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203c : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
203d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
203f : 48              >            pha         ;use stack to load status
2040 : a97f            >            lda #$7f     ;precharge accu
2042 : 28              >            plp
                        
2043 : d509                     cmp zp1,x
                                tst_a $7f,fzc
2045 : 08              >            php         ;save flags
2046 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2048 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204a : 68              >            pla         ;load status
204b : 48              >            pha
                       >            cmp_flag fzc
204c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
204e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2050 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2051 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2053 : 48              >            pha         ;use stack to load status
2054 : a97e            >            lda #$7e     ;precharge accu
2056 : 28              >            plp
                        
2057 : d509                     cmp zp1,x
                                tst_a $7e,fn
2059 : 08              >            php         ;save flags
205a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
205c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
205e : 68              >            pla         ;load status
205f : 48              >            pha
                       >            cmp_flag fn
2060 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2062 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2064 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2065 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2067 : 48              >            pha         ;use stack to load status
2068 : a980            >            lda #$80     ;precharge accu
206a : 28              >            plp
                        
206b : d509                     cmp zp1,x
                                tst_a $80,~fnz
206d : 08              >            php         ;save flags
206e : c980            >            cmp #$80     ;test result
                       >            trap_ne
2070 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2072 : 68              >            pla         ;load status
2073 : 48              >            pha
                       >            cmp_flag ~fnz
2074 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2076 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2078 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2079 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
207b : 48              >            pha         ;use stack to load status
207c : a97f            >            lda #$7f     ;precharge accu
207e : 28              >            plp
                        
207f : d509                     cmp zp1,x
                                tst_a $7f,~fn
2081 : 08              >            php         ;save flags
2082 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2084 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2086 : 68              >            pla         ;load status
2087 : 48              >            pha
                       >            cmp_flag ~fn
2088 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
208a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
208d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
208f : 48              >            pha         ;use stack to load status
2090 : a97e            >            lda #$7e     ;precharge accu
2092 : 28              >            plp
                        
2093 : d509                     cmp zp1,x
                                tst_a $7e,~fzc
2095 : 08              >            php         ;save flags
2096 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2098 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
209a : 68              >            pla         ;load status
209b : 48              >            pha
                       >            cmp_flag ~fzc
209c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
209e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a0 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
20a1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20a3 : 48              >            pha         ;use stack to load status
20a4 : a980            >            lda #$80     ;precharge accu
20a6 : 28              >            plp
                        
20a7 : dd1702                   cmp abs1,x
                                tst_a $80,fc
20aa : 08              >            php         ;save flags
20ab : c980            >            cmp #$80     ;test result
                       >            trap_ne
20ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20af : 68              >            pla         ;load status
20b0 : 48              >            pha
                       >            cmp_flag fc
20b1 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b5 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20b6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20b8 : 48              >            pha         ;use stack to load status
20b9 : a97f            >            lda #$7f     ;precharge accu
20bb : 28              >            plp
                        
20bc : dd1702                   cmp abs1,x
                                tst_a $7f,fzc
20bf : 08              >            php         ;save flags
20c0 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c4 : 68              >            pla         ;load status
20c5 : 48              >            pha
                       >            cmp_flag fzc
20c6 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ca : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20cd : 48              >            pha         ;use stack to load status
20ce : a97e            >            lda #$7e     ;precharge accu
20d0 : 28              >            plp
                        
20d1 : dd1702                   cmp abs1,x
                                tst_a $7e,fn
20d4 : 08              >            php         ;save flags
20d5 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d9 : 68              >            pla         ;load status
20da : 48              >            pha
                       >            cmp_flag fn
20db : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20df : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20e0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20e2 : 48              >            pha         ;use stack to load status
20e3 : a980            >            lda #$80     ;precharge accu
20e5 : 28              >            plp
                        
20e6 : dd1702                   cmp abs1,x
                                tst_a $80,~fnz
20e9 : 08              >            php         ;save flags
20ea : c980            >            cmp #$80     ;test result
                       >            trap_ne
20ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ee : 68              >            pla         ;load status
20ef : 48              >            pha
                       >            cmp_flag ~fnz
20f0 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f4 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20f7 : 48              >            pha         ;use stack to load status
20f8 : a97f            >            lda #$7f     ;precharge accu
20fa : 28              >            plp
                        
20fb : dd1702                   cmp abs1,x
                                tst_a $7f,~fn
20fe : 08              >            php         ;save flags
20ff : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2101 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2103 : 68              >            pla         ;load status
2104 : 48              >            pha
                       >            cmp_flag ~fn
2105 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2107 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2109 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
210a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
210c : 48              >            pha         ;use stack to load status
210d : a97e            >            lda #$7e     ;precharge accu
210f : 28              >            plp
                        
2110 : dd1702                   cmp abs1,x
                                tst_a $7e,~fzc
2113 : 08              >            php         ;save flags
2114 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2116 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2118 : 68              >            pla         ;load status
2119 : 48              >            pha
                       >            cmp_flag ~fzc
211a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
211c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211e : 28              >            plp         ;restore status
                        
                        
211f : a004                     ldy #4          ;with indexing by Y
2121 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
2123 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2125 : 48              >            pha         ;use stack to load status
2126 : a980            >            lda #$80     ;precharge accu
2128 : 28              >            plp
                        
2129 : d91702                   cmp abs1,y
                                tst_a $80,fc
212c : 08              >            php         ;save flags
212d : c980            >            cmp #$80     ;test result
                       >            trap_ne
212f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2131 : 68              >            pla         ;load status
2132 : 48              >            pha
                       >            cmp_flag fc
2133 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2135 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2137 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2138 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
213a : 48              >            pha         ;use stack to load status
213b : a97f            >            lda #$7f     ;precharge accu
213d : 28              >            plp
                        
213e : d91702                   cmp abs1,y
                                tst_a $7f,fzc
2141 : 08              >            php         ;save flags
2142 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2144 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2146 : 68              >            pla         ;load status
2147 : 48              >            pha
                       >            cmp_flag fzc
2148 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
214a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214c : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
214d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
214f : 48              >            pha         ;use stack to load status
2150 : a97e            >            lda #$7e     ;precharge accu
2152 : 28              >            plp
                        
2153 : d91702                   cmp abs1,y
                                tst_a $7e,fn
2156 : 08              >            php         ;save flags
2157 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2159 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215b : 68              >            pla         ;load status
215c : 48              >            pha
                       >            cmp_flag fn
215d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
215f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2161 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2162 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2164 : 48              >            pha         ;use stack to load status
2165 : a980            >            lda #$80     ;precharge accu
2167 : 28              >            plp
                        
2168 : d91702                   cmp abs1,y
                                tst_a $80,~fnz
216b : 08              >            php         ;save flags
216c : c980            >            cmp #$80     ;test result
                       >            trap_ne
216e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2170 : 68              >            pla         ;load status
2171 : 48              >            pha
                       >            cmp_flag ~fnz
2172 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2174 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2176 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2177 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2179 : 48              >            pha         ;use stack to load status
217a : a97f            >            lda #$7f     ;precharge accu
217c : 28              >            plp
                        
217d : d91702                   cmp abs1,y
                                tst_a $7f,~fn
2180 : 08              >            php         ;save flags
2181 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2183 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2185 : 68              >            pla         ;load status
2186 : 48              >            pha
                       >            cmp_flag ~fn
2187 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2189 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218b : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
218c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
218e : 48              >            pha         ;use stack to load status
218f : a97e            >            lda #$7e     ;precharge accu
2191 : 28              >            plp
                        
2192 : d91702                   cmp abs1,y
                                tst_a $7e,~fzc
2195 : 08              >            php         ;save flags
2196 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2198 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219a : 68              >            pla         ;load status
219b : 48              >            pha
                       >            cmp_flag ~fzc
219c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
219e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a0 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21a1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21a3 : 48              >            pha         ;use stack to load status
21a4 : a980            >            lda #$80     ;precharge accu
21a6 : 28              >            plp
                        
21a7 : c11a                     cmp (ind1,x)
                                tst_a $80,fc
21a9 : 08              >            php         ;save flags
21aa : c980            >            cmp #$80     ;test result
                       >            trap_ne
21ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ae : 68              >            pla         ;load status
21af : 48              >            pha
                       >            cmp_flag fc
21b0 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b4 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
21b5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21b7 : 48              >            pha         ;use stack to load status
21b8 : a97f            >            lda #$7f     ;precharge accu
21ba : 28              >            plp
                        
21bb : c11a                     cmp (ind1,x)
                                tst_a $7f,fzc
21bd : 08              >            php         ;save flags
21be : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c2 : 68              >            pla         ;load status
21c3 : 48              >            pha
                       >            cmp_flag fzc
21c4 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c8 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21c9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21cb : 48              >            pha         ;use stack to load status
21cc : a97e            >            lda #$7e     ;precharge accu
21ce : 28              >            plp
                        
21cf : c11a                     cmp (ind1,x)
                                tst_a $7e,fn
21d1 : 08              >            php         ;save flags
21d2 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d6 : 68              >            pla         ;load status
21d7 : 48              >            pha
                       >            cmp_flag fn
21d8 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21dc : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21dd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21df : 48              >            pha         ;use stack to load status
21e0 : a980            >            lda #$80     ;precharge accu
21e2 : 28              >            plp
                        
21e3 : c11a                     cmp (ind1,x)
                                tst_a $80,~fnz
21e5 : 08              >            php         ;save flags
21e6 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ea : 68              >            pla         ;load status
21eb : 48              >            pha
                       >            cmp_flag ~fnz
21ec : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f0 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21f1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21f3 : 48              >            pha         ;use stack to load status
21f4 : a97f            >            lda #$7f     ;precharge accu
21f6 : 28              >            plp
                        
21f7 : c11a                     cmp (ind1,x)
                                tst_a $7f,~fn
21f9 : 08              >            php         ;save flags
21fa : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21fe : 68              >            pla         ;load status
21ff : 48              >            pha
                       >            cmp_flag ~fn
2200 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2202 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2204 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2205 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2207 : 48              >            pha         ;use stack to load status
2208 : a97e            >            lda #$7e     ;precharge accu
220a : 28              >            plp
                        
220b : c11a                     cmp (ind1,x)
                                tst_a $7e,~fzc
220d : 08              >            php         ;save flags
220e : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2210 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2212 : 68              >            pla         ;load status
2213 : 48              >            pha
                       >            cmp_flag ~fzc
2214 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2216 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2218 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2219 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
221b : 48              >            pha         ;use stack to load status
221c : a980            >            lda #$80     ;precharge accu
221e : 28              >            plp
                        
221f : d11a                     cmp (ind1),y
                                tst_a $80,fc
2221 : 08              >            php         ;save flags
2222 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2224 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2226 : 68              >            pla         ;load status
2227 : 48              >            pha
                       >            cmp_flag fc
2228 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
222a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222c : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
222d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
222f : 48              >            pha         ;use stack to load status
2230 : a97f            >            lda #$7f     ;precharge accu
2232 : 28              >            plp
                        
2233 : d11a                     cmp (ind1),y
                                tst_a $7f,fzc
2235 : 08              >            php         ;save flags
2236 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2238 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223a : 68              >            pla         ;load status
223b : 48              >            pha
                       >            cmp_flag fzc
223c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
223e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2240 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2241 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2243 : 48              >            pha         ;use stack to load status
2244 : a97e            >            lda #$7e     ;precharge accu
2246 : 28              >            plp
                        
2247 : d11a                     cmp (ind1),y
                                tst_a $7e,fn
2249 : 08              >            php         ;save flags
224a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
224c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
224e : 68              >            pla         ;load status
224f : 48              >            pha
                       >            cmp_flag fn
2250 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2252 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2254 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2255 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2257 : 48              >            pha         ;use stack to load status
2258 : a980            >            lda #$80     ;precharge accu
225a : 28              >            plp
                        
225b : d11a                     cmp (ind1),y
                                tst_a $80,~fnz
225d : 08              >            php         ;save flags
225e : c980            >            cmp #$80     ;test result
                       >            trap_ne
2260 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2262 : 68              >            pla         ;load status
2263 : 48              >            pha
                       >            cmp_flag ~fnz
2264 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2266 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2268 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2269 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
226b : 48              >            pha         ;use stack to load status
226c : a97f            >            lda #$7f     ;precharge accu
226e : 28              >            plp
                        
226f : d11a                     cmp (ind1),y
                                tst_a $7f,~fn
2271 : 08              >            php         ;save flags
2272 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2274 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2276 : 68              >            pla         ;load status
2277 : 48              >            pha
                       >            cmp_flag ~fn
2278 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
227a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
227c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
227d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
227f : 48              >            pha         ;use stack to load status
2280 : a97e            >            lda #$7e     ;precharge accu
2282 : 28              >            plp
                        
2283 : d11a                     cmp (ind1),y
                                tst_a $7e,~fzc
2285 : 08              >            php         ;save flags
2286 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2288 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
228a : 68              >            pla         ;load status
228b : 48              >            pha
                       >            cmp_flag ~fzc
228c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
228e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2290 : 28              >            plp         ;restore status
                        
                                next_test
2291 : ad0002          >            lda test_case   ;previous test
2294 : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2296 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
2298 : a91d            >            lda #test_num   ;*** next tests' number
229a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
229d : a203                     ldx #3
229f :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
229f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22a1 : 48              >            pha         ;use stack to load status
22a2 : b509            >            lda zp1,x    ;precharge accu
22a4 : 28              >            plp
                        
22a5 : 0a                       asl a
                                tst_ax rASL,fASL,0
22a6 : 08              >            php         ;save flags
22a7 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
22aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ac : 68              >            pla         ;load status
                       >            eor_flag 0
22ad : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22af : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22b4 : ca                       dex
22b5 : 10e8                     bpl tasl
22b7 : a203                     ldx #3
22b9 :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
22b9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22bb : 48              >            pha         ;use stack to load status
22bc : b509            >            lda zp1,x    ;precharge accu
22be : 28              >            plp
                        
22bf : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
22c0 : 08              >            php         ;save flags
22c1 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
22c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22c7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22c9 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22ce : ca                       dex
22cf : 10e8                     bpl tasl1
                        
22d1 : a203                     ldx #3
22d3 :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
22d3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22d5 : 48              >            pha         ;use stack to load status
22d6 : b509            >            lda zp1,x    ;precharge accu
22d8 : 28              >            plp
                        
22d9 : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
22da : 08              >            php         ;save flags
22db : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
22de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e0 : 68              >            pla         ;load status
                       >            eor_flag 0
22e1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22e3 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22e8 : ca                       dex
22e9 : 10e8                     bpl tlsr
22eb : a203                     ldx #3
22ed :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
22ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22ef : 48              >            pha         ;use stack to load status
22f0 : b509            >            lda zp1,x    ;precharge accu
22f2 : 28              >            plp
                        
22f3 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
22f4 : 08              >            php         ;save flags
22f5 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
22f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22fa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22fb : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22fd : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2300 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2302 : ca                       dex
2303 : 10e8                     bpl tlsr1
                        
2305 : a203                     ldx #3
2307 :                  trol
                                set_ax zp1,0
                       >            load_flag 0
2307 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2309 : 48              >            pha         ;use stack to load status
230a : b509            >            lda zp1,x    ;precharge accu
230c : 28              >            plp
                        
230d : 2a                       rol a
                                tst_ax rROL,fROL,0
230e : 08              >            php         ;save flags
230f : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2312 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2314 : 68              >            pla         ;load status
                       >            eor_flag 0
2315 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2317 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
231a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
231c : ca                       dex
231d : 10e8                     bpl trol
231f : a203                     ldx #3
2321 :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
2321 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2323 : 48              >            pha         ;use stack to load status
2324 : b509            >            lda zp1,x    ;precharge accu
2326 : 28              >            plp
                        
2327 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
2328 : 08              >            php         ;save flags
2329 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
232c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
232e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
232f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2331 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2334 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2336 : ca                       dex
2337 : 10e8                     bpl trol1
                        
2339 : a203                     ldx #3
233b :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
233b : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
233d : 48              >            pha         ;use stack to load status
233e : b509            >            lda zp1,x    ;precharge accu
2340 : 28              >            plp
                        
2341 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2342 : 08              >            php         ;save flags
2343 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2346 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2348 : 68              >            pla         ;load status
                       >            eor_flag 0
2349 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
234b : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
234e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2350 : ca                       dex
2351 : 10e8                     bpl trolc
2353 : a203                     ldx #3
2355 :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2355 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2357 : 48              >            pha         ;use stack to load status
2358 : b509            >            lda zp1,x    ;precharge accu
235a : 28              >            plp
                        
235b : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
235c : 08              >            php         ;save flags
235d : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2360 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2362 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2363 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2365 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2368 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
236a : ca                       dex
236b : 10e8                     bpl trolc1
                        
236d : a203                     ldx #3
236f :                  tror
                                set_ax zp1,0
                       >            load_flag 0
236f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2371 : 48              >            pha         ;use stack to load status
2372 : b509            >            lda zp1,x    ;precharge accu
2374 : 28              >            plp
                        
2375 : 6a                       ror a
                                tst_ax rROR,fROR,0
2376 : 08              >            php         ;save flags
2377 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
237a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
237c : 68              >            pla         ;load status
                       >            eor_flag 0
237d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
237f : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2382 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2384 : ca                       dex
2385 : 10e8                     bpl tror
2387 : a203                     ldx #3
2389 :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
2389 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
238b : 48              >            pha         ;use stack to load status
238c : b509            >            lda zp1,x    ;precharge accu
238e : 28              >            plp
                        
238f : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
2390 : 08              >            php         ;save flags
2391 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2394 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2396 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2397 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2399 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
239c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
239e : ca                       dex
239f : 10e8                     bpl tror1
                        
23a1 : a203                     ldx #3
23a3 :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
23a3 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
23a5 : 48              >            pha         ;use stack to load status
23a6 : b509            >            lda zp1,x    ;precharge accu
23a8 : 28              >            plp
                        
23a9 : 6a                       ror a
                                tst_ax rRORc,fRORc,0
23aa : 08              >            php         ;save flags
23ab : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
23ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23b0 : 68              >            pla         ;load status
                       >            eor_flag 0
23b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23b3 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23b8 : ca                       dex
23b9 : 10e8                     bpl trorc
23bb : a203                     ldx #3
23bd :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
23bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23bf : 48              >            pha         ;use stack to load status
23c0 : b509            >            lda zp1,x    ;precharge accu
23c2 : 28              >            plp
                        
23c3 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
23c4 : 08              >            php         ;save flags
23c5 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
23c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ca : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23cb : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23cd : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23d2 : ca                       dex
23d3 : 10e8                     bpl trorc1
                                next_test
23d5 : ad0002          >            lda test_case   ;previous test
23d8 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
23da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
23dc : a91e            >            lda #test_num   ;*** next tests' number
23de : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
23e1 : a203                     ldx #3
23e3 :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
23e3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23e5 : 48              >            pha         ;use stack to load status
23e6 : b509            >            lda zp1,x    ;load to zeropage
23e8 : 8502            >            sta zpt
23ea : 28              >            plp
                        
23eb : 0602                     asl zpt
                                tst_z rASL,fASL,0
23ed : 08              >            php         ;save flags
23ee : a502            >            lda zpt
23f0 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
23f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23f5 : 68              >            pla         ;load status
                       >            eor_flag 0
23f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23f8 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
23fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23fd : ca                       dex
23fe : 10e3                     bpl tasl2
2400 : a203                     ldx #3
2402 :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
2402 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2404 : 48              >            pha         ;use stack to load status
2405 : b509            >            lda zp1,x    ;load to zeropage
2407 : 8502            >            sta zpt
2409 : 28              >            plp
                        
240a : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
240c : 08              >            php         ;save flags
240d : a502            >            lda zpt
240f : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2412 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2414 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2415 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2417 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
241a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
241c : ca                       dex
241d : 10e3                     bpl tasl3
                        
241f : a203                     ldx #3
2421 :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
2421 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2423 : 48              >            pha         ;use stack to load status
2424 : b509            >            lda zp1,x    ;load to zeropage
2426 : 8502            >            sta zpt
2428 : 28              >            plp
                        
2429 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
242b : 08              >            php         ;save flags
242c : a502            >            lda zpt
242e : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2431 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2433 : 68              >            pla         ;load status
                       >            eor_flag 0
2434 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2436 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2439 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
243b : ca                       dex
243c : 10e3                     bpl tlsr2
243e : a203                     ldx #3
2440 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
2440 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2442 : 48              >            pha         ;use stack to load status
2443 : b509            >            lda zp1,x    ;load to zeropage
2445 : 8502            >            sta zpt
2447 : 28              >            plp
                        
2448 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
244a : 08              >            php         ;save flags
244b : a502            >            lda zpt
244d : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2450 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2452 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2453 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2455 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2458 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
245a : ca                       dex
245b : 10e3                     bpl tlsr3
                        
245d : a203                     ldx #3
245f :                  trol2
                                set_z zp1,0
                       >            load_flag 0
245f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2461 : 48              >            pha         ;use stack to load status
2462 : b509            >            lda zp1,x    ;load to zeropage
2464 : 8502            >            sta zpt
2466 : 28              >            plp
                        
2467 : 2602                     rol zpt
                                tst_z rROL,fROL,0
2469 : 08              >            php         ;save flags
246a : a502            >            lda zpt
246c : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
246f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2471 : 68              >            pla         ;load status
                       >            eor_flag 0
2472 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2474 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2477 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2479 : ca                       dex
247a : 10e3                     bpl trol2
247c : a203                     ldx #3
247e :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
247e : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2480 : 48              >            pha         ;use stack to load status
2481 : b509            >            lda zp1,x    ;load to zeropage
2483 : 8502            >            sta zpt
2485 : 28              >            plp
                        
2486 : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
2488 : 08              >            php         ;save flags
2489 : a502            >            lda zpt
248b : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
248e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2490 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2491 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2493 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2496 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2498 : ca                       dex
2499 : 10e3                     bpl trol3
                        
249b : a203                     ldx #3
249d :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
249d : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
249f : 48              >            pha         ;use stack to load status
24a0 : b509            >            lda zp1,x    ;load to zeropage
24a2 : 8502            >            sta zpt
24a4 : 28              >            plp
                        
24a5 : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
24a7 : 08              >            php         ;save flags
24a8 : a502            >            lda zpt
24aa : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
24ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24af : 68              >            pla         ;load status
                       >            eor_flag 0
24b0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24b2 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24b7 : ca                       dex
24b8 : 10e3                     bpl trolc2
24ba : a203                     ldx #3
24bc :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
24bc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
24be : 48              >            pha         ;use stack to load status
24bf : b509            >            lda zp1,x    ;load to zeropage
24c1 : 8502            >            sta zpt
24c3 : 28              >            plp
                        
24c4 : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
24c6 : 08              >            php         ;save flags
24c7 : a502            >            lda zpt
24c9 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
24cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ce : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24cf : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24d1 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24d6 : ca                       dex
24d7 : 10e3                     bpl trolc3
                        
24d9 : a203                     ldx #3
24db :                  tror2
                                set_z zp1,0
                       >            load_flag 0
24db : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24dd : 48              >            pha         ;use stack to load status
24de : b509            >            lda zp1,x    ;load to zeropage
24e0 : 8502            >            sta zpt
24e2 : 28              >            plp
                        
24e3 : 6602                     ror zpt
                                tst_z rROR,fROR,0
24e5 : 08              >            php         ;save flags
24e6 : a502            >            lda zpt
24e8 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
24eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ed : 68              >            pla         ;load status
                       >            eor_flag 0
24ee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24f0 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
24f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24f5 : ca                       dex
24f6 : 10e3                     bpl tror2
24f8 : a203                     ldx #3
24fa :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24fa : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24fc : 48              >            pha         ;use stack to load status
24fd : b509            >            lda zp1,x    ;load to zeropage
24ff : 8502            >            sta zpt
2501 : 28              >            plp
                        
2502 : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
2504 : 08              >            php         ;save flags
2505 : a502            >            lda zpt
2507 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
250a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
250c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
250d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
250f : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2512 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2514 : ca                       dex
2515 : 10e3                     bpl tror3
                        
2517 : a203                     ldx #3
2519 :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
2519 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
251b : 48              >            pha         ;use stack to load status
251c : b509            >            lda zp1,x    ;load to zeropage
251e : 8502            >            sta zpt
2520 : 28              >            plp
                        
2521 : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
2523 : 08              >            php         ;save flags
2524 : a502            >            lda zpt
2526 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2529 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
252b : 68              >            pla         ;load status
                       >            eor_flag 0
252c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
252e : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2531 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2533 : ca                       dex
2534 : 10e3                     bpl trorc2
2536 : a203                     ldx #3
2538 :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
2538 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
253a : 48              >            pha         ;use stack to load status
253b : b509            >            lda zp1,x    ;load to zeropage
253d : 8502            >            sta zpt
253f : 28              >            plp
                        
2540 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
2542 : 08              >            php         ;save flags
2543 : a502            >            lda zpt
2545 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2548 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
254a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
254b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
254d : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2550 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2552 : ca                       dex
2553 : 10e3                     bpl trorc3
                                next_test
2555 : ad0002          >            lda test_case   ;previous test
2558 : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
255a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
255c : a91f            >            lda #test_num   ;*** next tests' number
255e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
2561 : a203                     ldx #3
2563 :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
2563 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2565 : 48              >            pha         ;use stack to load status
2566 : b509            >            lda zp1,x    ;load to memory
2568 : 8d0302          >            sta abst
256b : 28              >            plp
                        
256c : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
256f : 08              >            php         ;save flags
2570 : ad0302          >            lda abst
2573 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2576 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2578 : 68              >            pla         ;load status
                       >            eor_flag 0
2579 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
257b : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
257e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2580 : ca                       dex
2581 : 10e0                     bpl tasl4
2583 : a203                     ldx #3
2585 :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
2585 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2587 : 48              >            pha         ;use stack to load status
2588 : b509            >            lda zp1,x    ;load to memory
258a : 8d0302          >            sta abst
258d : 28              >            plp
                        
258e : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
2591 : 08              >            php         ;save flags
2592 : ad0302          >            lda abst
2595 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2598 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
259a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
259b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
259d : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
25a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25a2 : ca                       dex
25a3 : 10e0                     bpl tasl5
                        
25a5 : a203                     ldx #3
25a7 :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
25a7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25a9 : 48              >            pha         ;use stack to load status
25aa : b509            >            lda zp1,x    ;load to memory
25ac : 8d0302          >            sta abst
25af : 28              >            plp
                        
25b0 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
25b3 : 08              >            php         ;save flags
25b4 : ad0302          >            lda abst
25b7 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
25ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25bc : 68              >            pla         ;load status
                       >            eor_flag 0
25bd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25bf : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25c4 : ca                       dex
25c5 : 10e0                     bpl tlsr4
25c7 : a203                     ldx #3
25c9 :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
25c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25cb : 48              >            pha         ;use stack to load status
25cc : b509            >            lda zp1,x    ;load to memory
25ce : 8d0302          >            sta abst
25d1 : 28              >            plp
                        
25d2 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
25d5 : 08              >            php         ;save flags
25d6 : ad0302          >            lda abst
25d9 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
25dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25de : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25df : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25e1 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25e6 : ca                       dex
25e7 : 10e0                     bpl tlsr5
                        
25e9 : a203                     ldx #3
25eb :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
25eb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25ed : 48              >            pha         ;use stack to load status
25ee : b509            >            lda zp1,x    ;load to memory
25f0 : 8d0302          >            sta abst
25f3 : 28              >            plp
                        
25f4 : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
25f7 : 08              >            php         ;save flags
25f8 : ad0302          >            lda abst
25fb : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
25fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2600 : 68              >            pla         ;load status
                       >            eor_flag 0
2601 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2603 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2606 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2608 : ca                       dex
2609 : 10e0                     bpl trol4
260b : a203                     ldx #3
260d :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
260d : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
260f : 48              >            pha         ;use stack to load status
2610 : b509            >            lda zp1,x    ;load to memory
2612 : 8d0302          >            sta abst
2615 : 28              >            plp
                        
2616 : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
2619 : 08              >            php         ;save flags
261a : ad0302          >            lda abst
261d : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2620 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2622 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2623 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2625 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2628 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
262a : ca                       dex
262b : 10e0                     bpl trol5
                        
262d : a203                     ldx #3
262f :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
262f : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2631 : 48              >            pha         ;use stack to load status
2632 : b509            >            lda zp1,x    ;load to memory
2634 : 8d0302          >            sta abst
2637 : 28              >            plp
                        
2638 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
263b : 08              >            php         ;save flags
263c : ad0302          >            lda abst
263f : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2642 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2644 : 68              >            pla         ;load status
                       >            eor_flag 0
2645 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2647 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
264a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
264c : ca                       dex
264d : 10e0                     bpl trolc4
264f : a203                     ldx #3
2651 :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2651 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2653 : 48              >            pha         ;use stack to load status
2654 : b509            >            lda zp1,x    ;load to memory
2656 : 8d0302          >            sta abst
2659 : 28              >            plp
                        
265a : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
265d : 08              >            php         ;save flags
265e : ad0302          >            lda abst
2661 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2664 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2666 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2667 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2669 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
266c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
266e : ca                       dex
266f : 10e0                     bpl trolc5
                        
2671 : a203                     ldx #3
2673 :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
2673 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2675 : 48              >            pha         ;use stack to load status
2676 : b509            >            lda zp1,x    ;load to memory
2678 : 8d0302          >            sta abst
267b : 28              >            plp
                        
267c : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
267f : 08              >            php         ;save flags
2680 : ad0302          >            lda abst
2683 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2686 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2688 : 68              >            pla         ;load status
                       >            eor_flag 0
2689 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
268b : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
268e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2690 : ca                       dex
2691 : 10e0                     bpl tror4
2693 : a203                     ldx #3
2695 :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2695 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2697 : 48              >            pha         ;use stack to load status
2698 : b509            >            lda zp1,x    ;load to memory
269a : 8d0302          >            sta abst
269d : 28              >            plp
                        
269e : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
26a1 : 08              >            php         ;save flags
26a2 : ad0302          >            lda abst
26a5 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
26a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26aa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26ab : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26ad : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
26b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26b2 : ca                       dex
26b3 : 10e0                     bpl tror5
                        
26b5 : a203                     ldx #3
26b7 :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
26b7 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
26b9 : 48              >            pha         ;use stack to load status
26ba : b509            >            lda zp1,x    ;load to memory
26bc : 8d0302          >            sta abst
26bf : 28              >            plp
                        
26c0 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
26c3 : 08              >            php         ;save flags
26c4 : ad0302          >            lda abst
26c7 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26cc : 68              >            pla         ;load status
                       >            eor_flag 0
26cd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26cf : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26d4 : ca                       dex
26d5 : 10e0                     bpl trorc4
26d7 : a203                     ldx #3
26d9 :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
26d9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26db : 48              >            pha         ;use stack to load status
26dc : b509            >            lda zp1,x    ;load to memory
26de : 8d0302          >            sta abst
26e1 : 28              >            plp
                        
26e2 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
26e5 : 08              >            php         ;save flags
26e6 : ad0302          >            lda abst
26e9 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26ee : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26ef : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26f1 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26f6 : ca                       dex
26f7 : 10e0                     bpl trorc5
                                next_test
26f9 : ad0002          >            lda test_case   ;previous test
26fc : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
26fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2700 : a920            >            lda #test_num   ;*** next tests' number
2702 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
2705 : a203                     ldx #3
2707 :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
2707 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2709 : 48              >            pha         ;use stack to load status
270a : b509            >            lda zp1,x    ;load to indexed zeropage
270c : 9502            >            sta zpt,x
270e : 28              >            plp
                        
270f : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
2711 : 08              >            php         ;save flags
2712 : b502            >            lda zpt,x
2714 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2717 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2719 : 68              >            pla         ;load status
                       >            eor_flag 0
271a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
271c : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
271f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2721 : ca                       dex
2722 : 10e3                     bpl tasl6
2724 : a203                     ldx #3
2726 :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
2726 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2728 : 48              >            pha         ;use stack to load status
2729 : b509            >            lda zp1,x    ;load to indexed zeropage
272b : 9502            >            sta zpt,x
272d : 28              >            plp
                        
272e : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2730 : 08              >            php         ;save flags
2731 : b502            >            lda zpt,x
2733 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2736 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2738 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2739 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
273b : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
273e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2740 : ca                       dex
2741 : 10e3                     bpl tasl7
                        
2743 : a203                     ldx #3
2745 :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
2745 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2747 : 48              >            pha         ;use stack to load status
2748 : b509            >            lda zp1,x    ;load to indexed zeropage
274a : 9502            >            sta zpt,x
274c : 28              >            plp
                        
274d : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
274f : 08              >            php         ;save flags
2750 : b502            >            lda zpt,x
2752 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2755 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2757 : 68              >            pla         ;load status
                       >            eor_flag 0
2758 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
275a : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
275d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
275f : ca                       dex
2760 : 10e3                     bpl tlsr6
2762 : a203                     ldx #3
2764 :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
2764 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2766 : 48              >            pha         ;use stack to load status
2767 : b509            >            lda zp1,x    ;load to indexed zeropage
2769 : 9502            >            sta zpt,x
276b : 28              >            plp
                        
276c : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
276e : 08              >            php         ;save flags
276f : b502            >            lda zpt,x
2771 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2774 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2776 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2777 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2779 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
277c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
277e : ca                       dex
277f : 10e3                     bpl tlsr7
                        
2781 : a203                     ldx #3
2783 :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
2783 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2785 : 48              >            pha         ;use stack to load status
2786 : b509            >            lda zp1,x    ;load to indexed zeropage
2788 : 9502            >            sta zpt,x
278a : 28              >            plp
                        
278b : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
278d : 08              >            php         ;save flags
278e : b502            >            lda zpt,x
2790 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2793 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2795 : 68              >            pla         ;load status
                       >            eor_flag 0
2796 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2798 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
279b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
279d : ca                       dex
279e : 10e3                     bpl trol6
27a0 : a203                     ldx #3
27a2 :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27a2 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27a4 : 48              >            pha         ;use stack to load status
27a5 : b509            >            lda zp1,x    ;load to indexed zeropage
27a7 : 9502            >            sta zpt,x
27a9 : 28              >            plp
                        
27aa : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
27ac : 08              >            php         ;save flags
27ad : b502            >            lda zpt,x
27af : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
27b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27b4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27b5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27b7 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
27ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27bc : ca                       dex
27bd : 10e3                     bpl trol7
                        
27bf : a203                     ldx #3
27c1 :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
27c1 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
27c3 : 48              >            pha         ;use stack to load status
27c4 : b509            >            lda zp1,x    ;load to indexed zeropage
27c6 : 9502            >            sta zpt,x
27c8 : 28              >            plp
                        
27c9 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
27cb : 08              >            php         ;save flags
27cc : b502            >            lda zpt,x
27ce : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
27d1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27d3 : 68              >            pla         ;load status
                       >            eor_flag 0
27d4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27d6 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27d9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27db : ca                       dex
27dc : 10e3                     bpl trolc6
27de : a203                     ldx #3
27e0 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
27e0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27e2 : 48              >            pha         ;use stack to load status
27e3 : b509            >            lda zp1,x    ;load to indexed zeropage
27e5 : 9502            >            sta zpt,x
27e7 : 28              >            plp
                        
27e8 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
27ea : 08              >            php         ;save flags
27eb : b502            >            lda zpt,x
27ed : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
27f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27f2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27f3 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27f5 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27fa : ca                       dex
27fb : 10e3                     bpl trolc7
                        
27fd : a203                     ldx #3
27ff :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
27ff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2801 : 48              >            pha         ;use stack to load status
2802 : b509            >            lda zp1,x    ;load to indexed zeropage
2804 : 9502            >            sta zpt,x
2806 : 28              >            plp
                        
2807 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
2809 : 08              >            php         ;save flags
280a : b502            >            lda zpt,x
280c : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
280f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2811 : 68              >            pla         ;load status
                       >            eor_flag 0
2812 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2814 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2817 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2819 : ca                       dex
281a : 10e3                     bpl tror6
281c : a203                     ldx #3
281e :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
281e : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2820 : 48              >            pha         ;use stack to load status
2821 : b509            >            lda zp1,x    ;load to indexed zeropage
2823 : 9502            >            sta zpt,x
2825 : 28              >            plp
                        
2826 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2828 : 08              >            php         ;save flags
2829 : b502            >            lda zpt,x
282b : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
282e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2830 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2831 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2833 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2836 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2838 : ca                       dex
2839 : 10e3                     bpl tror7
                        
283b : a203                     ldx #3
283d :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
283d : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
283f : 48              >            pha         ;use stack to load status
2840 : b509            >            lda zp1,x    ;load to indexed zeropage
2842 : 9502            >            sta zpt,x
2844 : 28              >            plp
                        
2845 : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
2847 : 08              >            php         ;save flags
2848 : b502            >            lda zpt,x
284a : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
284d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
284f : 68              >            pla         ;load status
                       >            eor_flag 0
2850 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2852 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2855 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2857 : ca                       dex
2858 : 10e3                     bpl trorc6
285a : a203                     ldx #3
285c :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
285c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
285e : 48              >            pha         ;use stack to load status
285f : b509            >            lda zp1,x    ;load to indexed zeropage
2861 : 9502            >            sta zpt,x
2863 : 28              >            plp
                        
2864 : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
2866 : 08              >            php         ;save flags
2867 : b502            >            lda zpt,x
2869 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
286c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
286e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
286f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2871 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2874 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2876 : ca                       dex
2877 : 10e3                     bpl trorc7
                                next_test
2879 : ad0002          >            lda test_case   ;previous test
287c : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
287e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2880 : a921            >            lda #test_num   ;*** next tests' number
2882 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
2885 : a203                     ldx #3
2887 :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
2887 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2889 : 48              >            pha         ;use stack to load status
288a : b509            >            lda zp1,x    ;load to indexed memory
288c : 9d0302          >            sta abst,x
288f : 28              >            plp
                        
2890 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
2893 : 08              >            php         ;save flags
2894 : bd0302          >            lda abst,x
2897 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
289a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
289c : 68              >            pla         ;load status
                       >            eor_flag 0
289d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
289f : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
28a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28a4 : ca                       dex
28a5 : 10e0                     bpl tasl8
28a7 : a203                     ldx #3
28a9 :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
28a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28ab : 48              >            pha         ;use stack to load status
28ac : b509            >            lda zp1,x    ;load to indexed memory
28ae : 9d0302          >            sta abst,x
28b1 : 28              >            plp
                        
28b2 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
28b5 : 08              >            php         ;save flags
28b6 : bd0302          >            lda abst,x
28b9 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
28bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28be : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28bf : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28c1 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
28c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28c6 : ca                       dex
28c7 : 10e0                     bpl tasl9
                        
28c9 : a203                     ldx #3
28cb :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
28cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28cd : 48              >            pha         ;use stack to load status
28ce : b509            >            lda zp1,x    ;load to indexed memory
28d0 : 9d0302          >            sta abst,x
28d3 : 28              >            plp
                        
28d4 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
28d7 : 08              >            php         ;save flags
28d8 : bd0302          >            lda abst,x
28db : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
28de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28e0 : 68              >            pla         ;load status
                       >            eor_flag 0
28e1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28e3 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28e8 : ca                       dex
28e9 : 10e0                     bpl tlsr8
28eb : a203                     ldx #3
28ed :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
28ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28ef : 48              >            pha         ;use stack to load status
28f0 : b509            >            lda zp1,x    ;load to indexed memory
28f2 : 9d0302          >            sta abst,x
28f5 : 28              >            plp
                        
28f6 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
28f9 : 08              >            php         ;save flags
28fa : bd0302          >            lda abst,x
28fd : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2900 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2902 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2903 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2905 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2908 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
290a : ca                       dex
290b : 10e0                     bpl tlsr9
                        
290d : a203                     ldx #3
290f :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
290f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2911 : 48              >            pha         ;use stack to load status
2912 : b509            >            lda zp1,x    ;load to indexed memory
2914 : 9d0302          >            sta abst,x
2917 : 28              >            plp
                        
2918 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
291b : 08              >            php         ;save flags
291c : bd0302          >            lda abst,x
291f : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2922 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2924 : 68              >            pla         ;load status
                       >            eor_flag 0
2925 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2927 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
292a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
292c : ca                       dex
292d : 10e0                     bpl trol8
292f : a203                     ldx #3
2931 :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2931 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2933 : 48              >            pha         ;use stack to load status
2934 : b509            >            lda zp1,x    ;load to indexed memory
2936 : 9d0302          >            sta abst,x
2939 : 28              >            plp
                        
293a : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
293d : 08              >            php         ;save flags
293e : bd0302          >            lda abst,x
2941 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2944 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2946 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2947 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2949 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
294c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
294e : ca                       dex
294f : 10e0                     bpl trol9
                        
2951 : a203                     ldx #3
2953 :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
2953 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2955 : 48              >            pha         ;use stack to load status
2956 : b509            >            lda zp1,x    ;load to indexed memory
2958 : 9d0302          >            sta abst,x
295b : 28              >            plp
                        
295c : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
295f : 08              >            php         ;save flags
2960 : bd0302          >            lda abst,x
2963 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2966 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2968 : 68              >            pla         ;load status
                       >            eor_flag 0
2969 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
296b : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
296e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2970 : ca                       dex
2971 : 10e0                     bpl trolc8
2973 : a203                     ldx #3
2975 :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2975 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2977 : 48              >            pha         ;use stack to load status
2978 : b509            >            lda zp1,x    ;load to indexed memory
297a : 9d0302          >            sta abst,x
297d : 28              >            plp
                        
297e : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2981 : 08              >            php         ;save flags
2982 : bd0302          >            lda abst,x
2985 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2988 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
298a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
298b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
298d : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2990 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2992 : ca                       dex
2993 : 10e0                     bpl trolc9
                        
2995 : a203                     ldx #3
2997 :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
2997 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2999 : 48              >            pha         ;use stack to load status
299a : b509            >            lda zp1,x    ;load to indexed memory
299c : 9d0302          >            sta abst,x
299f : 28              >            plp
                        
29a0 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
29a3 : 08              >            php         ;save flags
29a4 : bd0302          >            lda abst,x
29a7 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
29aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29ac : 68              >            pla         ;load status
                       >            eor_flag 0
29ad : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29af : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
29b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29b4 : ca                       dex
29b5 : 10e0                     bpl tror8
29b7 : a203                     ldx #3
29b9 :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
29b9 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
29bb : 48              >            pha         ;use stack to load status
29bc : b509            >            lda zp1,x    ;load to indexed memory
29be : 9d0302          >            sta abst,x
29c1 : 28              >            plp
                        
29c2 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
29c5 : 08              >            php         ;save flags
29c6 : bd0302          >            lda abst,x
29c9 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
29cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29ce : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29cf : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29d1 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
29d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29d6 : ca                       dex
29d7 : 10e0                     bpl tror9
                        
29d9 : a203                     ldx #3
29db :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
29db : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
29dd : 48              >            pha         ;use stack to load status
29de : b509            >            lda zp1,x    ;load to indexed memory
29e0 : 9d0302          >            sta abst,x
29e3 : 28              >            plp
                        
29e4 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
29e7 : 08              >            php         ;save flags
29e8 : bd0302          >            lda abst,x
29eb : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29f0 : 68              >            pla         ;load status
                       >            eor_flag 0
29f1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29f3 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29f8 : ca                       dex
29f9 : 10e0                     bpl trorc8
29fb : a203                     ldx #3
29fd :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
29fd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29ff : 48              >            pha         ;use stack to load status
2a00 : b509            >            lda zp1,x    ;load to indexed memory
2a02 : 9d0302          >            sta abst,x
2a05 : 28              >            plp
                        
2a06 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2a09 : 08              >            php         ;save flags
2a0a : bd0302          >            lda abst,x
2a0d : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a12 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a13 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a15 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a1a : ca                       dex
2a1b : 10e0                     bpl trorc9
                                next_test
2a1d : ad0002          >            lda test_case   ;previous test
2a20 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2a24 : a922            >            lda #test_num   ;*** next tests' number
2a26 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2a29 : a200                     ldx #0
2a2b : a97e                     lda #$7e
2a2d : 8502                     sta zpt
2a2f :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a2f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a31 : 48              >            pha         ;use stack to load status
2a32 : 28              >            plp
                        
2a33 : e602                     inc zpt
                                tst_z rINC,fINC,0
2a35 : 08              >            php         ;save flags
2a36 : a502            >            lda zpt
2a38 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a3d : 68              >            pla         ;load status
                       >            eor_flag 0
2a3e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a40 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a45 : e8                       inx
2a46 : e002                     cpx #2
2a48 : d004                     bne tinc1
2a4a : a9fe                     lda #$fe
2a4c : 8502                     sta zpt
2a4e : e005             tinc1   cpx #5
2a50 : d0dd                     bne tinc
2a52 : ca                       dex
2a53 : e602                     inc zpt
2a55 :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a55 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a57 : 48              >            pha         ;use stack to load status
2a58 : 28              >            plp
                        
2a59 : c602                     dec zpt
                                tst_z rINC,fINC,0
2a5b : 08              >            php         ;save flags
2a5c : a502            >            lda zpt
2a5e : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a63 : 68              >            pla         ;load status
                       >            eor_flag 0
2a64 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a66 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a6b : ca                       dex
2a6c : 300a                     bmi tdec1
2a6e : e001                     cpx #1
2a70 : d0e3                     bne tdec
2a72 : a981                     lda #$81
2a74 : 8502                     sta zpt
2a76 : d0dd                     bne tdec
2a78 :                  tdec1
2a78 : a200                     ldx #0
2a7a : a97e                     lda #$7e
2a7c : 8502                     sta zpt
2a7e :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2a7e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a80 : 48              >            pha         ;use stack to load status
2a81 : 28              >            plp
                        
2a82 : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2a84 : 08              >            php         ;save flags
2a85 : a502            >            lda zpt
2a87 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a8c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a8d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a8f : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a94 : e8                       inx
2a95 : e002                     cpx #2
2a97 : d004                     bne tinc11
2a99 : a9fe                     lda #$fe
2a9b : 8502                     sta zpt
2a9d : e005             tinc11  cpx #5
2a9f : d0dd                     bne tinc10
2aa1 : ca                       dex
2aa2 : e602                     inc zpt
2aa4 :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2aa4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2aa6 : 48              >            pha         ;use stack to load status
2aa7 : 28              >            plp
                        
2aa8 : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2aaa : 08              >            php         ;save flags
2aab : a502            >            lda zpt
2aad : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ab0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ab2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ab3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ab5 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ab8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2aba : ca                       dex
2abb : 300a                     bmi tdec11
2abd : e001                     cpx #1
2abf : d0e3                     bne tdec10
2ac1 : a981                     lda #$81
2ac3 : 8502                     sta zpt
2ac5 : d0dd                     bne tdec10
2ac7 :                  tdec11
                                next_test
2ac7 : ad0002          >            lda test_case   ;previous test
2aca : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2acc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2ace : a923            >            lda #test_num   ;*** next tests' number
2ad0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2ad3 : a200                     ldx #0
2ad5 : a97e                     lda #$7e
2ad7 : 8d0302                   sta abst
2ada :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2ada : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2adc : 48              >            pha         ;use stack to load status
2add : 28              >            plp
                        
2ade : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2ae1 : 08              >            php         ;save flags
2ae2 : ad0302          >            lda abst
2ae5 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ae8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aea : 68              >            pla         ;load status
                       >            eor_flag 0
2aeb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2aed : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2af0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2af2 : e8                       inx
2af3 : e002                     cpx #2
2af5 : d005                     bne tinc3
2af7 : a9fe                     lda #$fe
2af9 : 8d0302                   sta abst
2afc : e005             tinc3   cpx #5
2afe : d0da                     bne tinc2
2b00 : ca                       dex
2b01 : ee0302                   inc abst
2b04 :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2b04 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b06 : 48              >            pha         ;use stack to load status
2b07 : 28              >            plp
                        
2b08 : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2b0b : 08              >            php         ;save flags
2b0c : ad0302          >            lda abst
2b0f : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b14 : 68              >            pla         ;load status
                       >            eor_flag 0
2b15 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b17 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b1c : ca                       dex
2b1d : 300b                     bmi tdec3
2b1f : e001                     cpx #1
2b21 : d0e1                     bne tdec2
2b23 : a981                     lda #$81
2b25 : 8d0302                   sta abst
2b28 : d0da                     bne tdec2
2b2a :                  tdec3
2b2a : a200                     ldx #0
2b2c : a97e                     lda #$7e
2b2e : 8d0302                   sta abst
2b31 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b33 : 48              >            pha         ;use stack to load status
2b34 : 28              >            plp
                        
2b35 : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b38 : 08              >            php         ;save flags
2b39 : ad0302          >            lda abst
2b3c : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b3f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b41 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b42 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b44 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b49 : e8                       inx
2b4a : e002                     cpx #2
2b4c : d005                     bne tinc13
2b4e : a9fe                     lda #$fe
2b50 : 8d0302                   sta abst
2b53 : e005             tinc13   cpx #5
2b55 : d0da                     bne tinc12
2b57 : ca                       dex
2b58 : ee0302                   inc abst
2b5b :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2b5b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b5d : 48              >            pha         ;use stack to load status
2b5e : 28              >            plp
                        
2b5f : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2b62 : 08              >            php         ;save flags
2b63 : ad0302          >            lda abst
2b66 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b6b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b6c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b6e : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b73 : ca                       dex
2b74 : 300b                     bmi tdec13
2b76 : e001                     cpx #1
2b78 : d0e1                     bne tdec12
2b7a : a981                     lda #$81
2b7c : 8d0302                   sta abst
2b7f : d0da                     bne tdec12
2b81 :                  tdec13
                                next_test
2b81 : ad0002          >            lda test_case   ;previous test
2b84 : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2b88 : a924            >            lda #test_num   ;*** next tests' number
2b8a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2b8d : a200                     ldx #0
2b8f : a97e                     lda #$7e
2b91 : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2b93 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b95 : 48              >            pha         ;use stack to load status
2b96 : 28              >            plp
                        
2b97 : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
2b99 : 08              >            php         ;save flags
2b9a : b502            >            lda zpt,x
2b9c : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ba1 : 68              >            pla         ;load status
                       >            eor_flag 0
2ba2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ba4 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ba7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ba9 : b502                     lda zpt,x
2bab : e8                       inx
2bac : e002                     cpx #2
2bae : d002                     bne tinc5
2bb0 : a9fe                     lda #$fe
2bb2 : e005             tinc5   cpx #5
2bb4 : d0db                     bne tinc4
2bb6 : ca                       dex
2bb7 : a902                     lda #2
2bb9 : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2bbb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2bbd : 48              >            pha         ;use stack to load status
2bbe : 28              >            plp
                        
2bbf : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
2bc1 : 08              >            php         ;save flags
2bc2 : b502            >            lda zpt,x
2bc4 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bc9 : 68              >            pla         ;load status
                       >            eor_flag 0
2bca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2bcc : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bd1 : b502                     lda zpt,x
2bd3 : ca                       dex
2bd4 : 3008                     bmi tdec5
2bd6 : e001                     cpx #1
2bd8 : d0df                     bne tdec4
2bda : a981                     lda #$81
2bdc : d0db                     bne tdec4
2bde :                  tdec5
2bde : a200                     ldx #0
2be0 : a97e                     lda #$7e
2be2 : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2be4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2be6 : 48              >            pha         ;use stack to load status
2be7 : 28              >            plp
                        
2be8 : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2bea : 08              >            php         ;save flags
2beb : b502            >            lda zpt,x
2bed : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bf2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bf3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bf5 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bfa : b502                     lda zpt,x
2bfc : e8                       inx
2bfd : e002                     cpx #2
2bff : d002                     bne tinc15
2c01 : a9fe                     lda #$fe
2c03 : e005             tinc15  cpx #5
2c05 : d0db                     bne tinc14
2c07 : ca                       dex
2c08 : a902                     lda #2
2c0a : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2c0c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c0e : 48              >            pha         ;use stack to load status
2c0f : 28              >            plp
                        
2c10 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c12 : 08              >            php         ;save flags
2c13 : b502            >            lda zpt,x
2c15 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c1a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c1b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c1d : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c22 : b502                     lda zpt,x
2c24 : ca                       dex
2c25 : 3008                     bmi tdec15
2c27 : e001                     cpx #1
2c29 : d0df                     bne tdec14
2c2b : a981                     lda #$81
2c2d : d0db                     bne tdec14
2c2f :                  tdec15
                                next_test
2c2f : ad0002          >            lda test_case   ;previous test
2c32 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c36 : a925            >            lda #test_num   ;*** next tests' number
2c38 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c3b : a200                     ldx #0
2c3d : a97e                     lda #$7e
2c3f : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c42 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c44 : 48              >            pha         ;use stack to load status
2c45 : 28              >            plp
                        
2c46 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2c49 : 08              >            php         ;save flags
2c4a : bd0302          >            lda abst,x
2c4d : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c52 : 68              >            pla         ;load status
                       >            eor_flag 0
2c53 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c55 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c5a : bd0302                   lda abst,x
2c5d : e8                       inx
2c5e : e002                     cpx #2
2c60 : d002                     bne tinc7
2c62 : a9fe                     lda #$fe
2c64 : e005             tinc7   cpx #5
2c66 : d0d7                     bne tinc6
2c68 : ca                       dex
2c69 : a902                     lda #2
2c6b : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2c6e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c70 : 48              >            pha         ;use stack to load status
2c71 : 28              >            plp
                        
2c72 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2c75 : 08              >            php         ;save flags
2c76 : bd0302          >            lda abst,x
2c79 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c7e : 68              >            pla         ;load status
                       >            eor_flag 0
2c7f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c81 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c86 : bd0302                   lda abst,x
2c89 : ca                       dex
2c8a : 3008                     bmi tdec7
2c8c : e001                     cpx #1
2c8e : d0db                     bne tdec6
2c90 : a981                     lda #$81
2c92 : d0d7                     bne tdec6
2c94 :                  tdec7
2c94 : a200                     ldx #0
2c96 : a97e                     lda #$7e
2c98 : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2c9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c9d : 48              >            pha         ;use stack to load status
2c9e : 28              >            plp
                        
2c9f : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2ca2 : 08              >            php         ;save flags
2ca3 : bd0302          >            lda abst,x
2ca6 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ca9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cab : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cac : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cae : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cb3 : bd0302                   lda abst,x
2cb6 : e8                       inx
2cb7 : e002                     cpx #2
2cb9 : d002                     bne tinc17
2cbb : a9fe                     lda #$fe
2cbd : e005             tinc17  cpx #5
2cbf : d0d7                     bne tinc16
2cc1 : ca                       dex
2cc2 : a902                     lda #2
2cc4 : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2cc7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cc9 : 48              >            pha         ;use stack to load status
2cca : 28              >            plp
                        
2ccb : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2cce : 08              >            php         ;save flags
2ccf : bd0302          >            lda abst,x
2cd2 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2cd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cd7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cd8 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cda : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cdd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cdf : bd0302                   lda abst,x
2ce2 : ca                       dex
2ce3 : 3008                     bmi tdec17
2ce5 : e001                     cpx #1
2ce7 : d0db                     bne tdec16
2ce9 : a981                     lda #$81
2ceb : d0d7                     bne tdec16
2ced :                  tdec17
                                next_test
2ced : ad0002          >            lda test_case   ;previous test
2cf0 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2cf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2cf4 : a926            >            lda #test_num   ;*** next tests' number
2cf6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2cf9 : a203                     ldx #3          ;immediate
2cfb : b512             tand    lda zpAN,x
2cfd : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2d00 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d02 : 48              >            pha         ;use stack to load status
2d03 : bd5a02          >            lda absANa,x    ;precharge accu
2d06 : 28              >            plp
                        
2d07 : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2d0a : 08              >            php         ;save flags
2d0b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d10 : 68              >            pla         ;load status
                       >            eor_flag 0
2d11 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d13 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d18 : ca                       dex
2d19 : 10e0                     bpl tand
2d1b : a203                     ldx #3
2d1d : b512             tand1   lda zpAN,x
2d1f : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d22 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d24 : 48              >            pha         ;use stack to load status
2d25 : bd5a02          >            lda absANa,x    ;precharge accu
2d28 : 28              >            plp
                        
2d29 : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2d2c : 08              >            php         ;save flags
2d2d : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d32 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d33 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d35 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d3a : ca                       dex
2d3b : 10e0                     bpl tand1
                            
2d3d : a203                     ldx #3      ;zp
2d3f : b512             tand2   lda zpAN,x
2d41 : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d43 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d45 : 48              >            pha         ;use stack to load status
2d46 : bd5a02          >            lda absANa,x    ;precharge accu
2d49 : 28              >            plp
                        
2d4a : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
2d4c : 08              >            php         ;save flags
2d4d : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d52 : 68              >            pla         ;load status
                       >            eor_flag 0
2d53 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d55 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d5a : ca                       dex
2d5b : 10e2                     bpl tand2
2d5d : a203                     ldx #3
2d5f : b512             tand3   lda zpAN,x
2d61 : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d65 : 48              >            pha         ;use stack to load status
2d66 : bd5a02          >            lda absANa,x    ;precharge accu
2d69 : 28              >            plp
                        
2d6a : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2d6c : 08              >            php         ;save flags
2d6d : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d72 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d73 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d75 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d7a : ca                       dex
2d7b : 10e2                     bpl tand3
                        
2d7d : a203                     ldx #3      ;abs
2d7f : b512             tand4   lda zpAN,x
2d81 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2d84 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d86 : 48              >            pha         ;use stack to load status
2d87 : bd5a02          >            lda absANa,x    ;precharge accu
2d8a : 28              >            plp
                        
2d8b : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2d8e : 08              >            php         ;save flags
2d8f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d94 : 68              >            pla         ;load status
                       >            eor_flag 0
2d95 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d97 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d9c : ca                       dex
2d9d : 10e0                     bpl tand4
2d9f : a203                     ldx #3
2da1 : b512             tand5   lda zpAN,x
2da3 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2da6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2da8 : 48              >            pha         ;use stack to load status
2da9 : bd5a02          >            lda absANa,x    ;precharge accu
2dac : 28              >            plp
                        
2dad : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2db0 : 08              >            php         ;save flags
2db1 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2db4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2db6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2db7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2db9 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dbe : ca                       dex
2dbf : 1002                     bpl tand6
                        
2dc1 : a203                     ldx #3      ;zp,x
2dc3 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2dc3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dc5 : 48              >            pha         ;use stack to load status
2dc6 : bd5a02          >            lda absANa,x    ;precharge accu
2dc9 : 28              >            plp
                        
2dca : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2dcc : 08              >            php         ;save flags
2dcd : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dd2 : 68              >            pla         ;load status
                       >            eor_flag 0
2dd3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2dd5 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dda : ca                       dex
2ddb : 10e6                     bpl tand6
2ddd : a203                     ldx #3
2ddf :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2ddf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2de1 : 48              >            pha         ;use stack to load status
2de2 : bd5a02          >            lda absANa,x    ;precharge accu
2de5 : 28              >            plp
                        
2de6 : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2de8 : 08              >            php         ;save flags
2de9 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dee : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2def : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2df1 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2df4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2df6 : ca                       dex
2df7 : 10e6                     bpl tand7
                        
2df9 : a203                     ldx #3      ;abs,x
2dfb :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2dfb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dfd : 48              >            pha         ;use stack to load status
2dfe : bd5a02          >            lda absANa,x    ;precharge accu
2e01 : 28              >            plp
                        
2e02 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2e05 : 08              >            php         ;save flags
2e06 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e0b : 68              >            pla         ;load status
                       >            eor_flag 0
2e0c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e0e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e13 : ca                       dex
2e14 : 10e5                     bpl tand8
2e16 : a203                     ldx #3
2e18 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e18 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e1a : 48              >            pha         ;use stack to load status
2e1b : bd5a02          >            lda absANa,x    ;precharge accu
2e1e : 28              >            plp
                        
2e1f : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e22 : 08              >            php         ;save flags
2e23 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e28 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e29 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e2b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e30 : ca                       dex
2e31 : 10e5                     bpl tand9
                        
2e33 : a003                     ldy #3      ;abs,y
2e35 :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e35 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e37 : 48              >            pha         ;use stack to load status
2e38 : b95a02          >            lda absANa,y    ;precharge accu
2e3b : 28              >            plp
                        
2e3c : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e3f : 08              >            php         ;save flags
2e40 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e45 : 68              >            pla         ;load status
                       >            eor_flag 0
2e46 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e48 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e4d : 88                       dey
2e4e : 10e5                     bpl tand10
2e50 : a003                     ldy #3
2e52 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e54 : 48              >            pha         ;use stack to load status
2e55 : b95a02          >            lda absANa,y    ;precharge accu
2e58 : 28              >            plp
                        
2e59 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2e5c : 08              >            php         ;save flags
2e5d : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e62 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e63 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e65 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e6a : 88                       dey
2e6b : 10e5                     bpl tand11
                        
2e6d : a206                     ldx #6      ;(zp,x)
2e6f : a003                     ldy #3
2e71 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2e71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e73 : 48              >            pha         ;use stack to load status
2e74 : b95a02          >            lda absANa,y    ;precharge accu
2e77 : 28              >            plp
                        
2e78 : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2e7a : 08              >            php         ;save flags
2e7b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e80 : 68              >            pla         ;load status
                       >            eor_flag 0
2e81 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e83 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e88 : ca                       dex
2e89 : ca                       dex
2e8a : 88                       dey
2e8b : 10e4                     bpl tand12
2e8d : a206                     ldx #6
2e8f : a003                     ldy #3
2e91 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e91 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e93 : 48              >            pha         ;use stack to load status
2e94 : b95a02          >            lda absANa,y    ;precharge accu
2e97 : 28              >            plp
                        
2e98 : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2e9a : 08              >            php         ;save flags
2e9b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ea0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ea1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ea3 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ea6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ea8 : ca                       dex
2ea9 : ca                       dex
2eaa : 88                       dey
2eab : 10e4                     bpl tand13
                        
2ead : a003                     ldy #3      ;(zp),y
2eaf :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2eaf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2eb1 : 48              >            pha         ;use stack to load status
2eb2 : b95a02          >            lda absANa,y    ;precharge accu
2eb5 : 28              >            plp
                        
2eb6 : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2eb8 : 08              >            php         ;save flags
2eb9 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ebc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ebe : 68              >            pla         ;load status
                       >            eor_flag 0
2ebf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ec1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ec4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ec6 : 88                       dey
2ec7 : 10e6                     bpl tand14
2ec9 : a003                     ldy #3
2ecb :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2ecb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ecd : 48              >            pha         ;use stack to load status
2ece : b95a02          >            lda absANa,y    ;precharge accu
2ed1 : 28              >            plp
                        
2ed2 : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2ed4 : 08              >            php         ;save flags
2ed5 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ed8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eda : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2edb : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2edd : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ee0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ee2 : 88                       dey
2ee3 : 10e6                     bpl tand15
                                next_test
2ee5 : ad0002          >            lda test_case   ;previous test
2ee8 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2eea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2eec : a927            >            lda #test_num   ;*** next tests' number
2eee : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2ef1 : a203                     ldx #3          ;immediate - self modifying code
2ef3 : b516             teor    lda zpEO,x
2ef5 : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2ef8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2efa : 48              >            pha         ;use stack to load status
2efb : bd5e02          >            lda absEOa,x    ;precharge accu
2efe : 28              >            plp
                        
2eff : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2f02 : 08              >            php         ;save flags
2f03 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f08 : 68              >            pla         ;load status
                       >            eor_flag 0
2f09 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f0b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f10 : ca                       dex
2f11 : 10e0                     bpl teor
2f13 : a203                     ldx #3
2f15 : b516             teor1   lda zpEO,x
2f17 : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f1a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f1c : 48              >            pha         ;use stack to load status
2f1d : bd5e02          >            lda absEOa,x    ;precharge accu
2f20 : 28              >            plp
                        
2f21 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2f24 : 08              >            php         ;save flags
2f25 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f2a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f2b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f2d : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f32 : ca                       dex
2f33 : 10e0                     bpl teor1
                            
2f35 : a203                     ldx #3      ;zp
2f37 : b516             teor2    lda zpEO,x
2f39 : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f3b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f3d : 48              >            pha         ;use stack to load status
2f3e : bd5e02          >            lda absEOa,x    ;precharge accu
2f41 : 28              >            plp
                        
2f42 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
2f44 : 08              >            php         ;save flags
2f45 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f4a : 68              >            pla         ;load status
                       >            eor_flag 0
2f4b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f4d : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f52 : ca                       dex
2f53 : 10e2                     bpl teor2
2f55 : a203                     ldx #3
2f57 : b516             teor3   lda zpEO,x
2f59 : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f5b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f5d : 48              >            pha         ;use stack to load status
2f5e : bd5e02          >            lda absEOa,x    ;precharge accu
2f61 : 28              >            plp
                        
2f62 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2f64 : 08              >            php         ;save flags
2f65 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f6a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f6b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f6d : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f72 : ca                       dex
2f73 : 10e2                     bpl teor3
                        
2f75 : a203                     ldx #3      ;abs
2f77 : b516             teor4   lda zpEO,x
2f79 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2f7c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f7e : 48              >            pha         ;use stack to load status
2f7f : bd5e02          >            lda absEOa,x    ;precharge accu
2f82 : 28              >            plp
                        
2f83 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2f86 : 08              >            php         ;save flags
2f87 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f8c : 68              >            pla         ;load status
                       >            eor_flag 0
2f8d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f8f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f94 : ca                       dex
2f95 : 10e0                     bpl teor4
2f97 : a203                     ldx #3
2f99 : b516             teor5   lda zpEO,x
2f9b : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f9e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fa0 : 48              >            pha         ;use stack to load status
2fa1 : bd5e02          >            lda absEOa,x    ;precharge accu
2fa4 : 28              >            plp
                        
2fa5 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2fa8 : 08              >            php         ;save flags
2fa9 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fae : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2faf : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fb1 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fb6 : ca                       dex
2fb7 : 1002                     bpl teor6
                        
2fb9 : a203                     ldx #3      ;zp,x
2fbb :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2fbb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fbd : 48              >            pha         ;use stack to load status
2fbe : bd5e02          >            lda absEOa,x    ;precharge accu
2fc1 : 28              >            plp
                        
2fc2 : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2fc4 : 08              >            php         ;save flags
2fc5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fca : 68              >            pla         ;load status
                       >            eor_flag 0
2fcb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fcd : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fd2 : ca                       dex
2fd3 : 10e6                     bpl teor6
2fd5 : a203                     ldx #3
2fd7 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fd7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fd9 : 48              >            pha         ;use stack to load status
2fda : bd5e02          >            lda absEOa,x    ;precharge accu
2fdd : 28              >            plp
                        
2fde : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2fe0 : 08              >            php         ;save flags
2fe1 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fe4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fe6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fe7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fe9 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fee : ca                       dex
2fef : 10e6                     bpl teor7
                        
2ff1 : a203                     ldx #3      ;abs,x
2ff3 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2ff3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ff5 : 48              >            pha         ;use stack to load status
2ff6 : bd5e02          >            lda absEOa,x    ;precharge accu
2ff9 : 28              >            plp
                        
2ffa : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,0
2ffd : 08              >            php         ;save flags
2ffe : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3001 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3003 : 68              >            pla         ;load status
                       >            eor_flag 0
3004 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3006 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3009 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
300b : ca                       dex
300c : 10e5                     bpl teor8
300e : a203                     ldx #3
3010 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3010 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3012 : 48              >            pha         ;use stack to load status
3013 : bd5e02          >            lda absEOa,x    ;precharge accu
3016 : 28              >            plp
                        
3017 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
301a : 08              >            php         ;save flags
301b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
301e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3020 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3021 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3023 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3026 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3028 : ca                       dex
3029 : 10e5                     bpl teor9
                        
302b : a003                     ldy #3      ;abs,y
302d :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
302d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
302f : 48              >            pha         ;use stack to load status
3030 : b95e02          >            lda absEOa,y    ;precharge accu
3033 : 28              >            plp
                        
3034 : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,0
3037 : 08              >            php         ;save flags
3038 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
303b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
303d : 68              >            pla         ;load status
                       >            eor_flag 0
303e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3040 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3043 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3045 : 88                       dey
3046 : 10e5                     bpl teor10
3048 : a003                     ldy #3
304a :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
304a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
304c : 48              >            pha         ;use stack to load status
304d : b95e02          >            lda absEOa,y    ;precharge accu
3050 : 28              >            plp
                        
3051 : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
3054 : 08              >            php         ;save flags
3055 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3058 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
305a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
305b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
305d : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3060 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3062 : 88                       dey
3063 : 10e5                     bpl teor11
                        
3065 : a206                     ldx #6      ;(zp,x)
3067 : a003                     ldy #3
3069 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
3069 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
306b : 48              >            pha         ;use stack to load status
306c : b95e02          >            lda absEOa,y    ;precharge accu
306f : 28              >            plp
                        
3070 : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3072 : 08              >            php         ;save flags
3073 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3076 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3078 : 68              >            pla         ;load status
                       >            eor_flag 0
3079 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
307b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
307e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3080 : ca                       dex
3081 : ca                       dex
3082 : 88                       dey
3083 : 10e4                     bpl teor12
3085 : a206                     ldx #6
3087 : a003                     ldy #3
3089 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3089 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
308b : 48              >            pha         ;use stack to load status
308c : b95e02          >            lda absEOa,y    ;precharge accu
308f : 28              >            plp
                        
3090 : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3092 : 08              >            php         ;save flags
3093 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3096 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3098 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3099 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
309b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
309e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30a0 : ca                       dex
30a1 : ca                       dex
30a2 : 88                       dey
30a3 : 10e4                     bpl teor13
                        
30a5 : a003                     ldy #3      ;(zp),y
30a7 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
30a7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30a9 : 48              >            pha         ;use stack to load status
30aa : b95e02          >            lda absEOa,y    ;precharge accu
30ad : 28              >            plp
                        
30ae : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
30b0 : 08              >            php         ;save flags
30b1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30b6 : 68              >            pla         ;load status
                       >            eor_flag 0
30b7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30b9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30be : 88                       dey
30bf : 10e6                     bpl teor14
30c1 : a003                     ldy #3
30c3 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
30c3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30c5 : 48              >            pha         ;use stack to load status
30c6 : b95e02          >            lda absEOa,y    ;precharge accu
30c9 : 28              >            plp
                        
30ca : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
30cc : 08              >            php         ;save flags
30cd : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30d2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30d3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30d5 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30da : 88                       dey
30db : 10e6                     bpl teor15
                                next_test
30dd : ad0002          >            lda test_case   ;previous test
30e0 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
30e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
30e4 : a928            >            lda #test_num   ;*** next tests' number
30e6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
30e9 : a203                     ldx #3          ;immediate - self modifying code
30eb : b50e             tora    lda zpOR,x
30ed : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
30f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30f2 : 48              >            pha         ;use stack to load status
30f3 : bd5602          >            lda absORa,x    ;precharge accu
30f6 : 28              >            plp
                        
30f7 : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
30fa : 08              >            php         ;save flags
30fb : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
30fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3100 : 68              >            pla         ;load status
                       >            eor_flag 0
3101 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3103 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3106 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3108 : ca                       dex
3109 : 10e0                     bpl tora
310b : a203                     ldx #3
310d : b50e             tora1   lda zpOR,x
310f : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
3112 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3114 : 48              >            pha         ;use stack to load status
3115 : bd5602          >            lda absORa,x    ;precharge accu
3118 : 28              >            plp
                        
3119 : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
311c : 08              >            php         ;save flags
311d : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3120 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3122 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3123 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3125 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3128 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
312a : ca                       dex
312b : 10e0                     bpl tora1
                            
312d : a203                     ldx #3      ;zp
312f : b50e             tora2   lda zpOR,x
3131 : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3133 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3135 : 48              >            pha         ;use stack to load status
3136 : bd5602          >            lda absORa,x    ;precharge accu
3139 : 28              >            plp
                        
313a : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
313c : 08              >            php         ;save flags
313d : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3140 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3142 : 68              >            pla         ;load status
                       >            eor_flag 0
3143 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3145 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3148 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
314a : ca                       dex
314b : 10e2                     bpl tora2
314d : a203                     ldx #3
314f : b50e             tora3   lda zpOR,x
3151 : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3153 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3155 : 48              >            pha         ;use stack to load status
3156 : bd5602          >            lda absORa,x    ;precharge accu
3159 : 28              >            plp
                        
315a : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
315c : 08              >            php         ;save flags
315d : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3160 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3162 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3163 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3165 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3168 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
316a : ca                       dex
316b : 10e2                     bpl tora3
                        
316d : a203                     ldx #3      ;abs
316f : b50e             tora4   lda zpOR,x
3171 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
3174 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3176 : 48              >            pha         ;use stack to load status
3177 : bd5602          >            lda absORa,x    ;precharge accu
317a : 28              >            plp
                        
317b : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
317e : 08              >            php         ;save flags
317f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3182 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3184 : 68              >            pla         ;load status
                       >            eor_flag 0
3185 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3187 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
318a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
318c : ca                       dex
318d : 10e0                     bpl tora4
318f : a203                     ldx #3
3191 : b50e             tora5   lda zpOR,x
3193 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
3196 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3198 : 48              >            pha         ;use stack to load status
3199 : bd5602          >            lda absORa,x    ;precharge accu
319c : 28              >            plp
                        
319d : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
31a0 : 08              >            php         ;save flags
31a1 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31a6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31a7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31a9 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31ae : ca                       dex
31af : 1002                     bpl tora6
                        
31b1 : a203                     ldx #3      ;zp,x
31b3 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
31b3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31b5 : 48              >            pha         ;use stack to load status
31b6 : bd5602          >            lda absORa,x    ;precharge accu
31b9 : 28              >            plp
                        
31ba : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
31bc : 08              >            php         ;save flags
31bd : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31c2 : 68              >            pla         ;load status
                       >            eor_flag 0
31c3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31c5 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31ca : ca                       dex
31cb : 10e6                     bpl tora6
31cd : a203                     ldx #3
31cf :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
31cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31d1 : 48              >            pha         ;use stack to load status
31d2 : bd5602          >            lda absORa,x    ;precharge accu
31d5 : 28              >            plp
                        
31d6 : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31d8 : 08              >            php         ;save flags
31d9 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31de : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31df : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31e1 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31e6 : ca                       dex
31e7 : 10e6                     bpl tora7
                        
31e9 : a203                     ldx #3      ;abs,x
31eb :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
31eb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31ed : 48              >            pha         ;use stack to load status
31ee : bd5602          >            lda absORa,x    ;precharge accu
31f1 : 28              >            plp
                        
31f2 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
31f5 : 08              >            php         ;save flags
31f6 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31fb : 68              >            pla         ;load status
                       >            eor_flag 0
31fc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31fe : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3201 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3203 : ca                       dex
3204 : 10e5                     bpl tora8
3206 : a203                     ldx #3
3208 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
3208 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
320a : 48              >            pha         ;use stack to load status
320b : bd5602          >            lda absORa,x    ;precharge accu
320e : 28              >            plp
                        
320f : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3212 : 08              >            php         ;save flags
3213 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3216 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3218 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3219 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
321b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
321e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3220 : ca                       dex
3221 : 10e5                     bpl tora9
                        
3223 : a003                     ldy #3      ;abs,y
3225 :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
3225 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3227 : 48              >            pha         ;use stack to load status
3228 : b95602          >            lda absORa,y    ;precharge accu
322b : 28              >            plp
                        
322c : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
322f : 08              >            php         ;save flags
3230 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3233 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3235 : 68              >            pla         ;load status
                       >            eor_flag 0
3236 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3238 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
323b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
323d : 88                       dey
323e : 10e5                     bpl tora10
3240 : a003                     ldy #3
3242 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3242 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3244 : 48              >            pha         ;use stack to load status
3245 : b95602          >            lda absORa,y    ;precharge accu
3248 : 28              >            plp
                        
3249 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
324c : 08              >            php         ;save flags
324d : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3250 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3252 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3253 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3255 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3258 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
325a : 88                       dey
325b : 10e5                     bpl tora11
                        
325d : a206                     ldx #6      ;(zp,x)
325f : a003                     ldy #3
3261 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
3261 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3263 : 48              >            pha         ;use stack to load status
3264 : b95602          >            lda absORa,y    ;precharge accu
3267 : 28              >            plp
                        
3268 : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
326a : 08              >            php         ;save flags
326b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
326e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3270 : 68              >            pla         ;load status
                       >            eor_flag 0
3271 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3273 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3276 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3278 : ca                       dex
3279 : ca                       dex
327a : 88                       dey
327b : 10e4                     bpl tora12
327d : a206                     ldx #6
327f : a003                     ldy #3
3281 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
3281 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3283 : 48              >            pha         ;use stack to load status
3284 : b95602          >            lda absORa,y    ;precharge accu
3287 : 28              >            plp
                        
3288 : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
328a : 08              >            php         ;save flags
328b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
328e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3290 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3291 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3293 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3296 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3298 : ca                       dex
3299 : ca                       dex
329a : 88                       dey
329b : 10e4                     bpl tora13
                        
329d : a003                     ldy #3      ;(zp),y
329f :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
329f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
32a1 : 48              >            pha         ;use stack to load status
32a2 : b95602          >            lda absORa,y    ;precharge accu
32a5 : 28              >            plp
                        
32a6 : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
32a8 : 08              >            php         ;save flags
32a9 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32ae : 68              >            pla         ;load status
                       >            eor_flag 0
32af : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
32b1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32b6 : 88                       dey
32b7 : 10e6                     bpl tora14
32b9 : a003                     ldy #3
32bb :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
32bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
32bd : 48              >            pha         ;use stack to load status
32be : b95602          >            lda absORa,y    ;precharge accu
32c1 : 28              >            plp
                        
32c2 : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
32c4 : 08              >            php         ;save flags
32c5 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32ca : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32cb : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
32cd : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32d2 : 88                       dey
32d3 : 10e6                     bpl tora15
                            if I_flag = 3
32d5 : 58                       cli
                            endif                
                                next_test
32d6 : ad0002          >            lda test_case   ;previous test
32d9 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
32db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
32dd : a929            >            lda #test_num   ;*** next tests' number
32df : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
32e2 : d8                       cld
32e3 : a204                     ldx #ad2        ;for indexed test
32e5 : a0ff                     ldy #$ff        ;max range
32e7 : a900                     lda #0          ;start with adding zeroes & no carry
32e9 : 8502                     sta adfc        ;carry in - for diag
32eb : 8503                     sta ad1         ;operand 1 - accumulator
32ed : 8504                     sta ad2         ;operand 2 - memory or immediate
32ef : 8d0302                   sta ada2        ;non zp
32f2 : 8505                     sta adrl        ;expected result bits 0-7
32f4 : 8506                     sta adrh        ;expected result bit 8 (carry out)
32f6 : a9ff                     lda #$ff        ;complemented operand 2 for subtract
32f8 : 8508                     sta sb2
32fa : 8d0402                   sta sba2        ;non zp
32fd : a902                     lda #2          ;expected Z-flag
32ff : 8507                     sta adrf
3301 : 18               tadd    clc             ;test with carry clear
3302 : 208135                   jsr chkadd
3305 : e602                     inc adfc        ;now with carry
3307 : e605                     inc adrl        ;result +1
3309 : 08                       php             ;save N & Z from low result
330a : 08                       php
330b : 68                       pla             ;accu holds expected flags
330c : 2982                     and #$82        ;mask N & Z
330e : 28                       plp
330f : d002                     bne tadd1
3311 : e606                     inc adrh        ;result bit 8 - carry
3313 : 0506             tadd1   ora adrh        ;merge C to expected flags
3315 : 8507                     sta adrf        ;save expected flags except overflow
3317 : 38                       sec             ;test with carry set
3318 : 208135                   jsr chkadd
331b : c602                     dec adfc        ;same for operand +1 but no carry
331d : e603                     inc ad1
331f : d0e0                     bne tadd        ;iterate op1
3321 : a900                     lda #0          ;preset result to op2 when op1 = 0
3323 : 8506                     sta adrh
3325 : ee0302                   inc ada2
3328 : e604                     inc ad2
332a : 08                       php             ;save NZ as operand 2 becomes the new result
332b : 68                       pla
332c : 2982                     and #$82        ;mask N00000Z0
332e : 8507                     sta adrf        ;no need to check carry as we are adding to 0
3330 : c608                     dec sb2         ;complement subtract operand 2
3332 : ce0402                   dec sba2
3335 : a504                     lda ad2         
3337 : 8505                     sta adrl
3339 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
333b : ad0002          >            lda test_case   ;previous test
333e : c929            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3340 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002a =                 >test_num = test_num + 1
3342 : a92a            >            lda #test_num   ;*** next tests' number
3344 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
3347 : f8                       sed 
3348 : a204                     ldx #ad2        ;for indexed test
334a : a0ff                     ldy #$ff        ;max range
334c : a999                     lda #$99        ;start with adding 99 to 99 with carry
334e : 8503                     sta ad1         ;operand 1 - accumulator
3350 : 8504                     sta ad2         ;operand 2 - memory or immediate
3352 : 8d0302                   sta ada2        ;non zp
3355 : 8505                     sta adrl        ;expected result bits 0-7
3357 : a901                     lda #1          ;set carry in & out
3359 : 8502                     sta adfc        ;carry in - for diag
335b : 8506                     sta adrh        ;expected result bit 8 (carry out)
335d : a900                     lda #0          ;complemented operand 2 for subtract
335f : 8508                     sta sb2
3361 : 8d0402                   sta sba2        ;non zp
3364 : 38               tdad    sec             ;test with carry set
3365 : 204e34                   jsr chkdad
3368 : c602                     dec adfc        ;now with carry clear
336a : a505                     lda adrl        ;decimal adjust result
336c : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
336e : c606                     dec adrh
3370 : a999                     lda #$99
3372 : 8505                     sta adrl
3374 : d012                     bne tdad3
3376 : 290f             tdad1   and #$f         ;lower nibble mask
3378 : d00c                     bne tdad2       ;no decimal adjust needed
337a : c605                     dec adrl        ;decimal adjust (?0-6)
337c : c605                     dec adrl
337e : c605                     dec adrl
3380 : c605                     dec adrl
3382 : c605                     dec adrl
3384 : c605                     dec adrl
3386 : c605             tdad2   dec adrl        ;result -1
3388 : 18               tdad3   clc             ;test with carry clear
3389 : 204e34                   jsr chkdad
338c : e602                     inc adfc        ;same for operand -1 but with carry
338e : a503                     lda ad1         ;decimal adjust operand 1
3390 : f015                     beq tdad5       ;iterate operand 2
3392 : 290f                     and #$f         ;lower nibble mask
3394 : d00c                     bne tdad4       ;skip decimal adjust
3396 : c603                     dec ad1         ;decimal adjust (?0-6)
3398 : c603                     dec ad1
339a : c603                     dec ad1
339c : c603                     dec ad1
339e : c603                     dec ad1
33a0 : c603                     dec ad1
33a2 : c603             tdad4   dec ad1         ;operand 1 -1
33a4 : 4c6433                   jmp tdad        ;iterate op1
                        
33a7 : a999             tdad5   lda #$99        ;precharge op1 max
33a9 : 8503                     sta ad1
33ab : a504                     lda ad2         ;decimal adjust operand 2
33ad : f030                     beq tdad7       ;end of iteration
33af : 290f                     and #$f         ;lower nibble mask
33b1 : d018                     bne tdad6       ;skip decimal adjust
33b3 : c604                     dec ad2         ;decimal adjust (?0-6)
33b5 : c604                     dec ad2
33b7 : c604                     dec ad2
33b9 : c604                     dec ad2
33bb : c604                     dec ad2
33bd : c604                     dec ad2
33bf : e608                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
33c1 : e608                     inc sb2
33c3 : e608                     inc sb2
33c5 : e608                     inc sb2
33c7 : e608                     inc sb2
33c9 : e608                     inc sb2
33cb : c604             tdad6   dec ad2         ;operand 2 -1
33cd : e608                     inc sb2         ;complemented operand for subtract
33cf : a508                     lda sb2
33d1 : 8d0402                   sta sba2        ;copy as non zp operand
33d4 : a504                     lda ad2
33d6 : 8d0302                   sta ada2        ;copy as non zp operand
33d9 : 8505                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
33db : e606                     inc adrh        ;result carry
33dd : d085                     bne tdad        ;iterate op2
33df :                  tdad7
                                next_test
33df : ad0002          >            lda test_case   ;previous test
33e2 : c92a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
33e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002b =                 >test_num = test_num + 1
33e6 : a92b            >            lda #test_num   ;*** next tests' number
33e8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
33eb : 18                       clc
33ec : d8                       cld
33ed : 08                       php
33ee : a955                     lda #$55
33f0 : 6955                     adc #$55
33f2 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after cld
33f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33f6 : 18                       clc
33f7 : f8                       sed
33f8 : 08                       php
33f9 : a955                     lda #$55
33fb : 6955                     adc #$55
33fd : c910                     cmp #$10
                                trap_ne         ;expected decimal result after sed
33ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
3401 : d8                       cld
3402 : 28                       plp
3403 : a955                     lda #$55
3405 : 6955                     adc #$55
3407 : c910                     cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
3409 : d0fe            >        bne *           ;failed not equal (non zero)
                        
340b : 28                       plp
340c : a955                     lda #$55
340e : 6955                     adc #$55
3410 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
3412 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3414 : 18                       clc
3415 : a934                     lda #hi bin_rti_ret ;emulated interrupt for rti
3417 : 48                       pha
3418 : a92f                     lda #lo bin_rti_ret
341a : 48                       pha
341b : 08                       php
341c : f8                       sed
341d : a934                     lda #hi dec_rti_ret ;emulated interrupt for rti
341f : 48                       pha
3420 : a926                     lda #lo dec_rti_ret
3422 : 48                       pha
3423 : 08                       php
3424 : d8                       cld
3425 : 40                       rti
3426 :                  dec_rti_ret
3426 : a955                     lda #$55
3428 : 6955                     adc #$55
342a : c910                     cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
342c : d0fe            >        bne *           ;failed not equal (non zero)
                        
342e : 40                       rti
342f :                  bin_rti_ret        
342f : a955                     lda #$55
3431 : 6955                     adc #$55
3433 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
3435 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            endif
                            
3437 : ad0002                   lda test_case
343a : c92b                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
343c : d0fe            >        bne *           ;failed not equal (non zero)
                        
343e : a9f0                     lda #$f0        ;mark opcode testing complete
3440 : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
3443 : a900            >	lda #0
3445 : 8d00ff          >	sta $ff00
3448 : 4c4834          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
344b : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
344e :                  chkdad
                        ; decimal ADC / SBC zp
344e : 08                       php             ;save carry for subtract
344f : a503                     lda ad1
3451 : 6504                     adc ad2         ;perform add
3453 : 08                       php          
3454 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3456 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3458 : 68                       pla             ;check flags
3459 : 2901                     and #1          ;mask carry
345b : c506                     cmp adrh
                                trap_ne         ;bad carry
345d : d0fe            >        bne *           ;failed not equal (non zero)
                        
345f : 28                       plp
3460 : 08                       php             ;save carry for next add
3461 : a503                     lda ad1
3463 : e508                     sbc sb2         ;perform subtract
3465 : 08                       php          
3466 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3468 : d0fe            >        bne *           ;failed not equal (non zero)
                        
346a : 68                       pla             ;check flags
346b : 2901                     and #1          ;mask carry
346d : c506                     cmp adrh
                                trap_ne         ;bad flags
346f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3471 : 28                       plp
                        ; decimal ADC / SBC abs
3472 : 08                       php             ;save carry for subtract
3473 : a503                     lda ad1
3475 : 6d0302                   adc ada2        ;perform add
3478 : 08                       php          
3479 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
347b : d0fe            >        bne *           ;failed not equal (non zero)
                        
347d : 68                       pla             ;check flags
347e : 2901                     and #1          ;mask carry
3480 : c506                     cmp adrh
                                trap_ne         ;bad carry
3482 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3484 : 28                       plp
3485 : 08                       php             ;save carry for next add
3486 : a503                     lda ad1
3488 : ed0402                   sbc sba2        ;perform subtract
348b : 08                       php          
348c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
348e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3490 : 68                       pla             ;check flags
3491 : 2901                     and #1          ;mask carry
3493 : c506                     cmp adrh
                                trap_ne         ;bad carry
3495 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3497 : 28                       plp
                        ; decimal ADC / SBC #
3498 : 08                       php             ;save carry for subtract
3499 : a504                     lda ad2
349b : 8d1202                   sta ex_adci+1   ;set ADC # operand
349e : a503                     lda ad1
34a0 : 201102                   jsr ex_adci     ;execute ADC # in RAM
34a3 : 08                       php          
34a4 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a8 : 68                       pla             ;check flags
34a9 : 2901                     and #1          ;mask carry
34ab : c506                     cmp adrh
                                trap_ne         ;bad carry
34ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
34af : 28                       plp
34b0 : 08                       php             ;save carry for next add
34b1 : a508                     lda sb2
34b3 : 8d1502                   sta ex_sbci+1   ;set SBC # operand
34b6 : a503                     lda ad1
34b8 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
34bb : 08                       php          
34bc : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34be : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c0 : 68                       pla             ;check flags
34c1 : 2901                     and #1          ;mask carry
34c3 : c506                     cmp adrh
                                trap_ne         ;bad carry
34c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c7 : 28                       plp
                        ; decimal ADC / SBC zp,x
34c8 : 08                       php             ;save carry for subtract
34c9 : a503                     lda ad1
34cb : 7500                     adc 0,x         ;perform add
34cd : 08                       php          
34ce : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d2 : 68                       pla             ;check flags
34d3 : 2901                     and #1          ;mask carry
34d5 : c506                     cmp adrh
                                trap_ne         ;bad carry
34d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d9 : 28                       plp
34da : 08                       php             ;save carry for next add
34db : a503                     lda ad1
34dd : f504                     sbc sb2-ad2,x   ;perform subtract
34df : 08                       php          
34e0 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34e4 : 68                       pla             ;check flags
34e5 : 2901                     and #1          ;mask carry
34e7 : c506                     cmp adrh
                                trap_ne         ;bad carry
34e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34eb : 28                       plp
                        ; decimal ADC / SBC abs,x
34ec : 08                       php             ;save carry for subtract
34ed : a503                     lda ad1
34ef : 7dff01                   adc ada2-ad2,x  ;perform add
34f2 : 08                       php          
34f3 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f7 : 68                       pla             ;check flags
34f8 : 2901                     and #1          ;mask carry
34fa : c506                     cmp adrh
                                trap_ne         ;bad carry
34fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
34fe : 28                       plp
34ff : 08                       php             ;save carry for next add
3500 : a503                     lda ad1
3502 : fd0002                   sbc sba2-ad2,x  ;perform subtract
3505 : 08                       php          
3506 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3508 : d0fe            >        bne *           ;failed not equal (non zero)
                        
350a : 68                       pla             ;check flags
350b : 2901                     and #1          ;mask carry
350d : c506                     cmp adrh
                                trap_ne         ;bad carry
350f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3511 : 28                       plp
                        ; decimal ADC / SBC abs,y
3512 : 08                       php             ;save carry for subtract
3513 : a503                     lda ad1
3515 : 790401                   adc ada2-$ff,y  ;perform add
3518 : 08                       php          
3519 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
351b : d0fe            >        bne *           ;failed not equal (non zero)
                        
351d : 68                       pla             ;check flags
351e : 2901                     and #1          ;mask carry
3520 : c506                     cmp adrh
                                trap_ne         ;bad carry
3522 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3524 : 28                       plp
3525 : 08                       php             ;save carry for next add
3526 : a503                     lda ad1
3528 : f90501                   sbc sba2-$ff,y  ;perform subtract
352b : 08                       php          
352c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
352e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3530 : 68                       pla             ;check flags
3531 : 2901                     and #1          ;mask carry
3533 : c506                     cmp adrh
                                trap_ne         ;bad carry
3535 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3537 : 28                       plp
                        ; decimal ADC / SBC (zp,x)
3538 : 08                       php             ;save carry for subtract
3539 : a503                     lda ad1
353b : 6144                     adc (lo adi2-ad2,x) ;perform add
353d : 08                       php          
353e : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3540 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3542 : 68                       pla             ;check flags
3543 : 2901                     and #1          ;mask carry
3545 : c506                     cmp adrh
                                trap_ne         ;bad carry
3547 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3549 : 28                       plp
354a : 08                       php             ;save carry for next add
354b : a503                     lda ad1
354d : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
354f : 08                       php          
3550 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3552 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3554 : 68                       pla             ;check flags
3555 : 2901                     and #1          ;mask carry
3557 : c506                     cmp adrh
                                trap_ne         ;bad carry
3559 : d0fe            >        bne *           ;failed not equal (non zero)
                        
355b : 28                       plp
                        ; decimal ADC / SBC (abs),y
355c : 08                       php             ;save carry for subtract
355d : a503                     lda ad1
355f : 714c                     adc (adiy2),y   ;perform add
3561 : 08                       php          
3562 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3564 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3566 : 68                       pla             ;check flags
3567 : 2901                     and #1          ;mask carry
3569 : c506                     cmp adrh
                                trap_ne         ;bad carry
356b : d0fe            >        bne *           ;failed not equal (non zero)
                        
356d : 28                       plp
356e : 08                       php             ;save carry for next add
356f : a503                     lda ad1
3571 : f14e                     sbc (sbiy2),y   ;perform subtract
3573 : 08                       php          
3574 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3576 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3578 : 68                       pla             ;check flags
3579 : 2901                     and #1          ;mask carry
357b : c506                     cmp adrh
                                trap_ne         ;bad carry
357d : d0fe            >        bne *           ;failed not equal (non zero)
                        
357f : 28                       plp
3580 : 60                       rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3581 : a507             chkadd  lda adrf        ;add V-flag if overflow
3583 : 2983                     and #$83        ;keep N-----ZC / clear V
3585 : 48                       pha
3586 : a503                     lda ad1         ;test sign unequal between operands
3588 : 4504                     eor ad2
358a : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
358c : a503                     lda ad1         ;test sign equal between operands and result
358e : 4505                     eor adrl
3590 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3592 : 68                       pla
3593 : 0940                     ora #$40        ;set V
3595 : 48                       pha
3596 : 68               ckad1   pla
3597 : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
3599 : 08                       php             ;save carry for subtract
359a : a503                     lda ad1
359c : 6504                     adc ad2         ;perform add
359e : 08                       php          
359f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a3 : 68                       pla             ;check flags
35a4 : 29c3                     and #$c3        ;mask NV----ZC
35a6 : c507                     cmp adrf
                                trap_ne         ;bad flags
35a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35aa : 28                       plp
35ab : 08                       php             ;save carry for next add
35ac : a503                     lda ad1
35ae : e508                     sbc sb2         ;perform subtract
35b0 : 08                       php          
35b1 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b5 : 68                       pla             ;check flags
35b6 : 29c3                     and #$c3        ;mask NV----ZC
35b8 : c507                     cmp adrf
                                trap_ne         ;bad flags
35ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
35bc : 28                       plp
                        ; binary ADC / SBC abs
35bd : 08                       php             ;save carry for subtract
35be : a503                     lda ad1
35c0 : 6d0302                   adc ada2        ;perform add
35c3 : 08                       php          
35c4 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c8 : 68                       pla             ;check flags
35c9 : 29c3                     and #$c3        ;mask NV----ZC
35cb : c507                     cmp adrf
                                trap_ne         ;bad flags
35cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
35cf : 28                       plp
35d0 : 08                       php             ;save carry for next add
35d1 : a503                     lda ad1
35d3 : ed0402                   sbc sba2        ;perform subtract
35d6 : 08                       php          
35d7 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35db : 68                       pla             ;check flags
35dc : 29c3                     and #$c3        ;mask NV----ZC
35de : c507                     cmp adrf
                                trap_ne         ;bad flags
35e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35e2 : 28                       plp
                        ; binary ADC / SBC #
35e3 : 08                       php             ;save carry for subtract
35e4 : a504                     lda ad2
35e6 : 8d1202                   sta ex_adci+1   ;set ADC # operand
35e9 : a503                     lda ad1
35eb : 201102                   jsr ex_adci     ;execute ADC # in RAM
35ee : 08                       php          
35ef : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f3 : 68                       pla             ;check flags
35f4 : 29c3                     and #$c3        ;mask NV----ZC
35f6 : c507                     cmp adrf
                                trap_ne         ;bad flags
35f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35fa : 28                       plp
35fb : 08                       php             ;save carry for next add
35fc : a508                     lda sb2
35fe : 8d1502                   sta ex_sbci+1   ;set SBC # operand
3601 : a503                     lda ad1
3603 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
3606 : 08                       php          
3607 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3609 : d0fe            >        bne *           ;failed not equal (non zero)
                        
360b : 68                       pla             ;check flags
360c : 29c3                     and #$c3        ;mask NV----ZC
360e : c507                     cmp adrf
                                trap_ne         ;bad flags
3610 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3612 : 28                       plp
                        ; binary ADC / SBC zp,x
3613 : 08                       php             ;save carry for subtract
3614 : a503                     lda ad1
3616 : 7500                     adc 0,x         ;perform add
3618 : 08                       php          
3619 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
361b : d0fe            >        bne *           ;failed not equal (non zero)
                        
361d : 68                       pla             ;check flags
361e : 29c3                     and #$c3        ;mask NV----ZC
3620 : c507                     cmp adrf
                                trap_ne         ;bad flags
3622 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3624 : 28                       plp
3625 : 08                       php             ;save carry for next add
3626 : a503                     lda ad1
3628 : f504                     sbc sb2-ad2,x   ;perform subtract
362a : 08                       php          
362b : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
362d : d0fe            >        bne *           ;failed not equal (non zero)
                        
362f : 68                       pla             ;check flags
3630 : 29c3                     and #$c3        ;mask NV----ZC
3632 : c507                     cmp adrf
                                trap_ne         ;bad flags
3634 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3636 : 28                       plp
                        ; binary ADC / SBC abs,x
3637 : 08                       php             ;save carry for subtract
3638 : a503                     lda ad1
363a : 7dff01                   adc ada2-ad2,x  ;perform add
363d : 08                       php          
363e : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3640 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3642 : 68                       pla             ;check flags
3643 : 29c3                     and #$c3        ;mask NV----ZC
3645 : c507                     cmp adrf
                                trap_ne         ;bad flags
3647 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3649 : 28                       plp
364a : 08                       php             ;save carry for next add
364b : a503                     lda ad1
364d : fd0002                   sbc sba2-ad2,x  ;perform subtract
3650 : 08                       php          
3651 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3653 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3655 : 68                       pla             ;check flags
3656 : 29c3                     and #$c3        ;mask NV----ZC
3658 : c507                     cmp adrf
                                trap_ne         ;bad flags
365a : d0fe            >        bne *           ;failed not equal (non zero)
                        
365c : 28                       plp
                        ; binary ADC / SBC abs,y
365d : 08                       php             ;save carry for subtract
365e : a503                     lda ad1
3660 : 790401                   adc ada2-$ff,y  ;perform add
3663 : 08                       php          
3664 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3666 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3668 : 68                       pla             ;check flags
3669 : 29c3                     and #$c3        ;mask NV----ZC
366b : c507                     cmp adrf
                                trap_ne         ;bad flags
366d : d0fe            >        bne *           ;failed not equal (non zero)
                        
366f : 28                       plp
3670 : 08                       php             ;save carry for next add
3671 : a503                     lda ad1
3673 : f90501                   sbc sba2-$ff,y  ;perform subtract
3676 : 08                       php          
3677 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3679 : d0fe            >        bne *           ;failed not equal (non zero)
                        
367b : 68                       pla             ;check flags
367c : 29c3                     and #$c3        ;mask NV----ZC
367e : c507                     cmp adrf
                                trap_ne         ;bad flags
3680 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3682 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3683 : 08                       php             ;save carry for subtract
3684 : a503                     lda ad1
3686 : 6144                     adc (lo adi2-ad2,x) ;perform add
3688 : 08                       php          
3689 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
368b : d0fe            >        bne *           ;failed not equal (non zero)
                        
368d : 68                       pla             ;check flags
368e : 29c3                     and #$c3        ;mask NV----ZC
3690 : c507                     cmp adrf
                                trap_ne         ;bad flags
3692 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3694 : 28                       plp
3695 : 08                       php             ;save carry for next add
3696 : a503                     lda ad1
3698 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
369a : 08                       php          
369b : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
369d : d0fe            >        bne *           ;failed not equal (non zero)
                        
369f : 68                       pla             ;check flags
36a0 : 29c3                     and #$c3        ;mask NV----ZC
36a2 : c507                     cmp adrf
                                trap_ne         ;bad flags
36a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36a6 : 28                       plp
                        ; binary ADC / SBC (abs),y
36a7 : 08                       php             ;save carry for subtract
36a8 : a503                     lda ad1
36aa : 714c                     adc (adiy2),y   ;perform add
36ac : 08                       php          
36ad : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
36af : d0fe            >        bne *           ;failed not equal (non zero)
                        
36b1 : 68                       pla             ;check flags
36b2 : 29c3                     and #$c3        ;mask NV----ZC
36b4 : c507                     cmp adrf
                                trap_ne         ;bad flags
36b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36b8 : 28                       plp
36b9 : 08                       php             ;save carry for next add
36ba : a503                     lda ad1
36bc : f14e                     sbc (sbiy2),y   ;perform subtract
36be : 08                       php          
36bf : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
36c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36c3 : 68                       pla             ;check flags
36c4 : 29c3                     and #$c3        ;mask NV----ZC
36c6 : c507                     cmp adrf
                                trap_ne         ;bad flags
36c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ca : 28                       plp
36cb : 60                       rts
                        
                        ; target for the jump absolute test
36cc : 88                       dey
36cd : 88                       dey
36ce :                  test_far
36ce : 08                       php             ;either SP or Y count will fail, if we do not hit
36cf : 88                       dey
36d0 : 88                       dey
36d1 : 88                       dey
36d2 : 28                       plp
                                trap_cs         ;flags loaded?
36d3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
36d5 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
36d7 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
36d9 : f0fe            >        beq *           ;failed equal (zero)
                        
36db : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
36dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
36df : e041                     cpx #'A'
                                trap_ne        
36e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e3 : c04f                     cpy #('R'-3)
                                trap_ne
36e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e7 : 48                       pha             ;save a,x
36e8 : 8a                       txa
36e9 : 48                       pha
36ea : ba                       tsx
36eb : e0fd                     cpx #$fd        ;check SP
                                trap_ne
36ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ef : 68                       pla             ;restore x
36f0 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
36f1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
36f3 : 48              >            pha         ;use stack to load status
36f4 : 28              >            plp
                        
36f5 : 68                       pla             ;restore a
36f6 : e8                       inx             ;return registers with modifications
36f7 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
36f9 : 4c0f09                   jmp far_ret
                                
                        ; target for the jump indirect test
                                align
36fc : 0537             ptr_tst_ind dw test_ind
36fe : 6409             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
3700 : 4c0037          >        jmp *           ;failed anyway
                        
3703 : 88                       dey
3704 : 88                       dey
3705 :                  test_ind
3705 : 08                       php             ;either SP or Y count will fail, if we do not hit
3706 : 88                       dey
3707 : 88                       dey
3708 : 88                       dey
3709 : 28                       plp
                                trap_cs         ;flags loaded?
370a : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
370c : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
370e : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3710 : f0fe            >        beq *           ;failed equal (zero)
                        
3712 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3714 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3716 : e04e                     cpx #'N'
                                trap_ne        
3718 : d0fe            >        bne *           ;failed not equal (non zero)
                        
371a : c041                     cpy #('D'-3)
                                trap_ne
371c : d0fe            >        bne *           ;failed not equal (non zero)
                        
371e : 48                       pha             ;save a,x
371f : 8a                       txa
3720 : 48                       pha
3721 : ba                       tsx
3722 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3724 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3726 : 68                       pla             ;restore x
3727 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3728 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
372a : 48              >            pha         ;use stack to load status
372b : 28              >            plp
                        
372c : 68                       pla             ;restore a
372d : e8                       inx             ;return registers with modifications
372e : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3730 : 6cfe36                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3733 : 4c3337          >        jmp *           ;failed anyway
                        
                        
                        ; target for the jump subroutine test
3736 : 88                       dey
3737 : 88                       dey
3738 :                  test_jsr
3738 : 08                       php             ;either SP or Y count will fail, if we do not hit
3739 : 88                       dey
373a : 88                       dey
373b : 88                       dey
373c : 28                       plp
                                trap_cs         ;flags loaded?
373d : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
373f : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3741 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3743 : f0fe            >        beq *           ;failed equal (zero)
                        
3745 : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3747 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3749 : e053                     cpx #'S'
                                trap_ne        
374b : d0fe            >        bne *           ;failed not equal (non zero)
                        
374d : c04f                     cpy #('R'-3)
                                trap_ne
374f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3751 : 48                       pha             ;save a,x
3752 : 8a                       txa
3753 : 48                       pha       
3754 : ba                       tsx             ;sp -4? (return addr,a,x)
3755 : e0fb                     cpx #$fb
                                trap_ne
3757 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3759 : adff01                   lda $1ff        ;propper return on stack
375c : c909                     cmp #hi(jsr_ret)
                                trap_ne
375e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3760 : adfe01                   lda $1fe
3763 : c99a                     cmp #lo(jsr_ret)
                                trap_ne
3765 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3767 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3769 : 48              >            pha         ;use stack to load status
376a : 28              >            plp
                        
376b : 68                       pla             ;pull x,a
376c : aa                       tax
376d : 68                       pla
376e : e8                       inx             ;return registers with modifications
376f : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3771 : 60                       rts
                                trap            ;runover protection
3772 : 4c7237          >        jmp *           ;failed anyway
                        
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3775 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3775 : 4c7537          >        jmp *           ;failed anyway
                        
3778 :                  res_trap
                                trap            ;unexpected RESET
3778 : 4c7837          >        jmp *           ;failed anyway
                        
                                
377b : 88                       dey
377c : 88                       dey
377d :                  irq_trap                ;BRK test or unextpected BRK or IRQ
377d : 08                       php             ;either SP or Y count will fail, if we do not hit
377e : 88                       dey
377f : 88                       dey
3780 : 88                       dey
                                ;next 4 traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
3781 : c942                     cmp #'B'        ;registers loaded?
                                trap_ne
3783 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3785 : e052                     cpx #'R'
                                trap_ne        
3787 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3789 : c048                     cpy #('K'-3)
                                trap_ne
378b : d0fe            >        bne *           ;failed not equal (non zero)
                        
378d : 8500                     sta irq_a       ;save registers during break test
378f : 8601                     stx irq_x
3791 : ba                       tsx             ;test break on stack
3792 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1
3795 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
3797 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3799 : 68                       pla
379a : c934                     cmp #fai        ;should have added interrupt disable
                                trap_ne
379c : d0fe            >        bne *           ;failed not equal (non zero)
                        
379e : ba                       tsx
379f : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
37a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37a3 : adff01                   lda $1ff        ;propper return on stack
37a6 : c909                     cmp #hi(brk_ret)
                                trap_ne
37a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37aa : adfe01                   lda $1fe
37ad : c9d1                     cmp #lo(brk_ret)
                                trap_ne
37af : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
37b1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
37b3 : 48              >            pha         ;use stack to load status
37b4 : 28              >            plp
                        
37b5 : a601                     ldx irq_x
37b7 : e8                       inx             ;return registers with modifications
37b8 : a500                     lda irq_a
37ba : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1 but original flags should be restored
37bc : 40                       rti
                                trap            ;runover protection
37bd : 4cbd37          >        jmp *           ;failed anyway
                        
                                
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : 7537                     dw  nmi_trap
fffc : 7837                     dw  res_trap
fffe : 7d37                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $0400 (1024).
